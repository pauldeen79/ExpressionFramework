// ------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version: 9.0.2
//  
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
// ------------------------------------------------------------------------------
#nullable enable
namespace ExpressionFramework.Domain.Expressions
{
    [System.ComponentModel.DescriptionAttribute(@"Aggregates context with other expressions")]
    public partial record AggregateExpression : ExpressionFramework.Domain.Expression
    {
        [System.ComponentModel.DataAnnotations.RequiredAttribute]
        [CrossCutting.Common.DataAnnotations.ValidateObjectAttribute]
        [System.ComponentModel.DescriptionAttribute(@"Aggregator to evaluate")]
        public System.Collections.Generic.IReadOnlyCollection<ExpressionFramework.Domain.Expression> Expressions
        {
            get;
        }

        [System.ComponentModel.DataAnnotations.RequiredAttribute]
        [CrossCutting.Common.DataAnnotations.ValidateObjectAttribute]
        [System.ComponentModel.DescriptionAttribute(@"Expressions to use in aggregator")]
        public ExpressionFramework.Domain.Aggregator Aggregator
        {
            get;
        }

        [CrossCutting.Common.DataAnnotations.ValidateObjectAttribute]
        [System.ComponentModel.DescriptionAttribute(@"Optional format provider to use on parsing numeric or date values")]
        public ExpressionFramework.Domain.Contracts.ITypedExpression<System.IFormatProvider>? FormatProviderExpression
        {
            get;
        }

        public AggregateExpression(System.Collections.Generic.IEnumerable<ExpressionFramework.Domain.Expression> expressions, ExpressionFramework.Domain.Aggregator aggregator, ExpressionFramework.Domain.Contracts.ITypedExpression<System.IFormatProvider>? formatProviderExpression) : base()
        {
            this.Expressions = expressions is null ? null! : new CrossCutting.Common.ReadOnlyValueCollection<ExpressionFramework.Domain.Expression>(expressions);
            this.Aggregator = aggregator;
            this.FormatProviderExpression = formatProviderExpression;
            System.ComponentModel.DataAnnotations.Validator.ValidateObject(this, new System.ComponentModel.DataAnnotations.ValidationContext(this, null, null), true);
        }

        public override ExpressionFramework.Domain.Builders.ExpressionBuilder ToBuilder()
        {
            return ToTypedBuilder();
        }

        public ExpressionFramework.Domain.Builders.Expressions.AggregateExpressionBuilder ToTypedBuilder()
        {
            return new ExpressionFramework.Domain.Builders.Expressions.AggregateExpressionBuilder(this);
        }
    }
    [System.ComponentModel.DescriptionAttribute(@"Returns an indicator whether all items from the (enumerable) expression conform to the predicate")]
    public partial record AllExpression : ExpressionFramework.Domain.Expression, ExpressionFramework.Domain.Contracts.ITypedExpression<bool>
    {
        [System.ComponentModel.DataAnnotations.RequiredAttribute]
        [CrossCutting.Common.DataAnnotations.ValidateObjectAttribute]
        [System.ComponentModel.DescriptionAttribute(@"Enumerable expression to use")]
        public ExpressionFramework.Domain.Contracts.ITypedExpression<System.Collections.IEnumerable> Expression
        {
            get;
        }

        [System.ComponentModel.DataAnnotations.RequiredAttribute]
        [CrossCutting.Common.DataAnnotations.ValidateObjectAttribute]
        [System.ComponentModel.DescriptionAttribute(@"Predicate to use")]
        public ExpressionFramework.Domain.Contracts.ITypedExpression<bool> PredicateExpression
        {
            get;
        }

        public AllExpression(ExpressionFramework.Domain.Contracts.ITypedExpression<System.Collections.IEnumerable> expression, ExpressionFramework.Domain.Contracts.ITypedExpression<bool> predicateExpression) : base()
        {
            this.Expression = expression;
            this.PredicateExpression = predicateExpression;
            System.ComponentModel.DataAnnotations.Validator.ValidateObject(this, new System.ComponentModel.DataAnnotations.ValidationContext(this, null, null), true);
        }

        public override ExpressionFramework.Domain.Builders.ExpressionBuilder ToBuilder()
        {
            return (ExpressionFramework.Domain.Builders.ExpressionBuilder)ToTypedBuilder();
        }

        public ExpressionFramework.Domain.Contracts.ITypedExpressionBuilder<bool> ToTypedBuilder()
        {
            return new ExpressionFramework.Domain.Builders.Expressions.AllExpressionBuilder(this);
        }

        public Expression ToUntyped()
        {
            return this;
        }
    }
    [System.ComponentModel.DescriptionAttribute(@"Returns the AND-combination value of two boolean expressions")]
    public partial record AndExpression : ExpressionFramework.Domain.Expression, ExpressionFramework.Domain.Contracts.ITypedExpression<bool>
    {
        [System.ComponentModel.DataAnnotations.RequiredAttribute]
        [CrossCutting.Common.DataAnnotations.ValidateObjectAttribute]
        [System.ComponentModel.DescriptionAttribute(@"First boolean expression to perform AND combination on")]
        public ExpressionFramework.Domain.Contracts.ITypedExpression<bool> FirstExpression
        {
            get;
        }

        [System.ComponentModel.DataAnnotations.RequiredAttribute]
        [CrossCutting.Common.DataAnnotations.ValidateObjectAttribute]
        [System.ComponentModel.DescriptionAttribute(@"Second boolean expression to perform AND combination on")]
        public ExpressionFramework.Domain.Contracts.ITypedExpression<bool> SecondExpression
        {
            get;
        }

        public AndExpression(ExpressionFramework.Domain.Contracts.ITypedExpression<bool> firstExpression, ExpressionFramework.Domain.Contracts.ITypedExpression<bool> secondExpression) : base()
        {
            this.FirstExpression = firstExpression;
            this.SecondExpression = secondExpression;
            System.ComponentModel.DataAnnotations.Validator.ValidateObject(this, new System.ComponentModel.DataAnnotations.ValidationContext(this, null, null), true);
        }

        public override ExpressionFramework.Domain.Builders.ExpressionBuilder ToBuilder()
        {
            return (ExpressionFramework.Domain.Builders.ExpressionBuilder)ToTypedBuilder();
        }

        public ExpressionFramework.Domain.Contracts.ITypedExpressionBuilder<bool> ToTypedBuilder()
        {
            return new ExpressionFramework.Domain.Builders.Expressions.AndExpressionBuilder(this);
        }

        public Expression ToUntyped()
        {
            return this;
        }
    }
    [System.ComponentModel.DescriptionAttribute(@"Returns an indicator whether any item from the (enumerable) expression conform to the optional predicate")]
    public partial record AnyExpression : ExpressionFramework.Domain.Expression, ExpressionFramework.Domain.Contracts.ITypedExpression<bool>
    {
        [System.ComponentModel.DataAnnotations.RequiredAttribute]
        [CrossCutting.Common.DataAnnotations.ValidateObjectAttribute]
        [System.ComponentModel.DescriptionAttribute(@"Enumerable expression to use")]
        public ExpressionFramework.Domain.Contracts.ITypedExpression<System.Collections.IEnumerable> Expression
        {
            get;
        }

        [CrossCutting.Common.DataAnnotations.ValidateObjectAttribute]
        [System.ComponentModel.DescriptionAttribute(@"Optional predicate to use")]
        public ExpressionFramework.Domain.Contracts.ITypedExpression<bool>? PredicateExpression
        {
            get;
        }

        public AnyExpression(ExpressionFramework.Domain.Contracts.ITypedExpression<System.Collections.IEnumerable> expression, ExpressionFramework.Domain.Contracts.ITypedExpression<bool>? predicateExpression) : base()
        {
            this.Expression = expression;
            this.PredicateExpression = predicateExpression;
            System.ComponentModel.DataAnnotations.Validator.ValidateObject(this, new System.ComponentModel.DataAnnotations.ValidationContext(this, null, null), true);
        }

        public override ExpressionFramework.Domain.Builders.ExpressionBuilder ToBuilder()
        {
            return (ExpressionFramework.Domain.Builders.ExpressionBuilder)ToTypedBuilder();
        }

        public ExpressionFramework.Domain.Contracts.ITypedExpressionBuilder<bool> ToTypedBuilder()
        {
            return new ExpressionFramework.Domain.Builders.Expressions.AnyExpressionBuilder(this);
        }

        public Expression ToUntyped()
        {
            return this;
        }
    }
    [System.ComponentModel.DescriptionAttribute(@"This expression returns the value of the source expression cast to the specified type")]
    public partial record CastExpression<T> : ExpressionFramework.Domain.Expression, ExpressionFramework.Domain.Contracts.ITypedExpression<T>
    {
        [System.ComponentModel.DataAnnotations.RequiredAttribute]
        [CrossCutting.Common.DataAnnotations.ValidateObjectAttribute]
        [System.ComponentModel.DescriptionAttribute(@"Expression to cast")]
        public ExpressionFramework.Domain.Expression SourceExpression
        {
            get;
        }

        public CastExpression(ExpressionFramework.Domain.Expression sourceExpression) : base()
        {
            this.SourceExpression = sourceExpression;
            System.ComponentModel.DataAnnotations.Validator.ValidateObject(this, new System.ComponentModel.DataAnnotations.ValidationContext(this, null, null), true);
        }

        public override ExpressionFramework.Domain.Builders.ExpressionBuilder ToBuilder()
        {
            return (ExpressionFramework.Domain.Builders.ExpressionBuilder)ToTypedBuilder();
        }

        public ExpressionFramework.Domain.Contracts.ITypedExpressionBuilder<T> ToTypedBuilder()
        {
            return new ExpressionFramework.Domain.Builders.Expressions.CastExpressionBuilder<T>(this);
        }
    }
    [System.ComponentModel.DescriptionAttribute(@"Chains the result of an expression onto the next one, and so on")]
    public partial record ChainedExpression : ExpressionFramework.Domain.Expression
    {
        [System.ComponentModel.DataAnnotations.RequiredAttribute]
        [CrossCutting.Common.DataAnnotations.ValidateObjectAttribute]
        [System.ComponentModel.DescriptionAttribute(@"Expressions to use on chaining. The context is chained to the first expression.")]
        public System.Collections.Generic.IReadOnlyCollection<ExpressionFramework.Domain.Expression> Expressions
        {
            get;
        }

        public ChainedExpression(System.Collections.Generic.IEnumerable<ExpressionFramework.Domain.Expression> expressions) : base()
        {
            this.Expressions = expressions is null ? null! : new CrossCutting.Common.ReadOnlyValueCollection<ExpressionFramework.Domain.Expression>(expressions);
            System.ComponentModel.DataAnnotations.Validator.ValidateObject(this, new System.ComponentModel.DataAnnotations.ValidationContext(this, null, null), true);
        }

        public override ExpressionFramework.Domain.Builders.ExpressionBuilder ToBuilder()
        {
            return ToTypedBuilder();
        }

        public ExpressionFramework.Domain.Builders.Expressions.ChainedExpressionBuilder ToTypedBuilder()
        {
            return new ExpressionFramework.Domain.Builders.Expressions.ChainedExpressionBuilder(this);
        }
    }
    [System.ComponentModel.DescriptionAttribute(@"Executes an aggregator on two expressions")]
    public partial record CompoundExpression : ExpressionFramework.Domain.Expression
    {
        [System.ComponentModel.DataAnnotations.RequiredAttribute]
        [CrossCutting.Common.DataAnnotations.ValidateObjectAttribute]
        [System.ComponentModel.DescriptionAttribute(@"Expression to use as first expression in aggregator")]
        public ExpressionFramework.Domain.Expression FirstExpression
        {
            get;
        }

        [System.ComponentModel.DataAnnotations.RequiredAttribute]
        [CrossCutting.Common.DataAnnotations.ValidateObjectAttribute]
        [System.ComponentModel.DescriptionAttribute(@"Expression to use as second expression in aggregator")]
        public ExpressionFramework.Domain.Expression SecondExpression
        {
            get;
        }

        [System.ComponentModel.DataAnnotations.RequiredAttribute]
        [CrossCutting.Common.DataAnnotations.ValidateObjectAttribute]
        [System.ComponentModel.DescriptionAttribute(@"Aggregator to evaluate")]
        public ExpressionFramework.Domain.Aggregator Aggregator
        {
            get;
        }

        [CrossCutting.Common.DataAnnotations.ValidateObjectAttribute]
        [System.ComponentModel.DescriptionAttribute(@"Optional format provider to use on parsing numeric or date values")]
        public ExpressionFramework.Domain.Contracts.ITypedExpression<System.IFormatProvider>? FormatProviderExpression
        {
            get;
        }

        public CompoundExpression(ExpressionFramework.Domain.Expression firstExpression, ExpressionFramework.Domain.Expression secondExpression, ExpressionFramework.Domain.Aggregator aggregator, ExpressionFramework.Domain.Contracts.ITypedExpression<System.IFormatProvider>? formatProviderExpression) : base()
        {
            this.FirstExpression = firstExpression;
            this.SecondExpression = secondExpression;
            this.Aggregator = aggregator;
            this.FormatProviderExpression = formatProviderExpression;
            System.ComponentModel.DataAnnotations.Validator.ValidateObject(this, new System.ComponentModel.DataAnnotations.ValidationContext(this, null, null), true);
        }

        public override ExpressionFramework.Domain.Builders.ExpressionBuilder ToBuilder()
        {
            return ToTypedBuilder();
        }

        public ExpressionFramework.Domain.Builders.Expressions.CompoundExpressionBuilder ToTypedBuilder()
        {
            return new ExpressionFramework.Domain.Builders.Expressions.CompoundExpressionBuilder(this);
        }
    }
    [System.ComponentModel.DescriptionAttribute(@"Returns a constant value")]
    public partial record ConstantExpression : ExpressionFramework.Domain.Expression
    {
        [System.ComponentModel.DescriptionAttribute(@"Value to use")]
        public object? Value
        {
            get;
        }

        public ConstantExpression(object? value) : base()
        {
            this.Value = value;
            System.ComponentModel.DataAnnotations.Validator.ValidateObject(this, new System.ComponentModel.DataAnnotations.ValidationContext(this, null, null), true);
        }

        public override ExpressionFramework.Domain.Builders.ExpressionBuilder ToBuilder()
        {
            return ToTypedBuilder();
        }

        public ExpressionFramework.Domain.Builders.Expressions.ConstantExpressionBuilder ToTypedBuilder()
        {
            return new ExpressionFramework.Domain.Builders.Expressions.ConstantExpressionBuilder(this);
        }
    }
    [System.ComponentModel.DescriptionAttribute(@"Returns a constant result")]
    public partial record ConstantResultExpression : ExpressionFramework.Domain.Expression
    {
        [System.ComponentModel.DataAnnotations.RequiredAttribute]
        [CrossCutting.Common.DataAnnotations.ValidateObjectAttribute]
        [System.ComponentModel.DescriptionAttribute(@"Result to use")]
        public CrossCutting.Common.Results.Result Value
        {
            get;
        }

        public ConstantResultExpression(CrossCutting.Common.Results.Result value) : base()
        {
            this.Value = value;
            System.ComponentModel.DataAnnotations.Validator.ValidateObject(this, new System.ComponentModel.DataAnnotations.ValidationContext(this, null, null), true);
        }

        public override ExpressionFramework.Domain.Builders.ExpressionBuilder ToBuilder()
        {
            return ToTypedBuilder();
        }

        public ExpressionFramework.Domain.Builders.Expressions.ConstantResultExpressionBuilder ToTypedBuilder()
        {
            return new ExpressionFramework.Domain.Builders.Expressions.ConstantResultExpressionBuilder(this);
        }
    }
    [System.ComponentModel.DescriptionAttribute(@"Returns the value of the context")]
    public partial record ContextExpression : ExpressionFramework.Domain.Expression
    {
        public ContextExpression() : base()
        {
            System.ComponentModel.DataAnnotations.Validator.ValidateObject(this, new System.ComponentModel.DataAnnotations.ValidationContext(this, null, null), true);
        }

        public override ExpressionFramework.Domain.Builders.ExpressionBuilder ToBuilder()
        {
            return ToTypedBuilder();
        }

        public ExpressionFramework.Domain.Builders.Expressions.ContextExpressionBuilder ToTypedBuilder()
        {
            return new ExpressionFramework.Domain.Builders.Expressions.ContextExpressionBuilder(this);
        }
    }
    [System.ComponentModel.DescriptionAttribute(@"Gets the number of items from the (enumerable) expression, optionally using a predicate")]
    public partial record CountExpression : ExpressionFramework.Domain.Expression, ExpressionFramework.Domain.Contracts.ITypedExpression<int>
    {
        [System.ComponentModel.DataAnnotations.RequiredAttribute]
        [CrossCutting.Common.DataAnnotations.ValidateObjectAttribute]
        [System.ComponentModel.DescriptionAttribute(@"Enumerable expression to use")]
        public ExpressionFramework.Domain.Contracts.ITypedExpression<System.Collections.IEnumerable> Expression
        {
            get;
        }

        [CrossCutting.Common.DataAnnotations.ValidateObjectAttribute]
        [System.ComponentModel.DescriptionAttribute(@"Optional predicate to use")]
        public ExpressionFramework.Domain.Contracts.ITypedExpression<bool>? PredicateExpression
        {
            get;
        }

        public CountExpression(ExpressionFramework.Domain.Contracts.ITypedExpression<System.Collections.IEnumerable> expression, ExpressionFramework.Domain.Contracts.ITypedExpression<bool>? predicateExpression) : base()
        {
            this.Expression = expression;
            this.PredicateExpression = predicateExpression;
            System.ComponentModel.DataAnnotations.Validator.ValidateObject(this, new System.ComponentModel.DataAnnotations.ValidationContext(this, null, null), true);
        }

        public override ExpressionFramework.Domain.Builders.ExpressionBuilder ToBuilder()
        {
            return (ExpressionFramework.Domain.Builders.ExpressionBuilder)ToTypedBuilder();
        }

        public ExpressionFramework.Domain.Contracts.ITypedExpressionBuilder<int> ToTypedBuilder()
        {
            return new ExpressionFramework.Domain.Builders.Expressions.CountExpressionBuilder(this);
        }

        public Expression ToUntyped()
        {
            return this;
        }
    }
    [System.ComponentModel.DescriptionAttribute(@"Returns the day from the specified DateTime expression")]
    public partial record DayExpression : ExpressionFramework.Domain.Expression, ExpressionFramework.Domain.Contracts.ITypedExpression<int>
    {
        [System.ComponentModel.DataAnnotations.RequiredAttribute]
        [CrossCutting.Common.DataAnnotations.ValidateObjectAttribute]
        [System.ComponentModel.DescriptionAttribute(@"DateTime source expression")]
        public ExpressionFramework.Domain.Contracts.ITypedExpression<System.DateTime> Expression
        {
            get;
        }

        public DayExpression(ExpressionFramework.Domain.Contracts.ITypedExpression<System.DateTime> expression) : base()
        {
            this.Expression = expression;
            System.ComponentModel.DataAnnotations.Validator.ValidateObject(this, new System.ComponentModel.DataAnnotations.ValidationContext(this, null, null), true);
        }

        public override ExpressionFramework.Domain.Builders.ExpressionBuilder ToBuilder()
        {
            return (ExpressionFramework.Domain.Builders.ExpressionBuilder)ToTypedBuilder();
        }

        public ExpressionFramework.Domain.Contracts.ITypedExpressionBuilder<int> ToTypedBuilder()
        {
            return new ExpressionFramework.Domain.Builders.Expressions.DayExpressionBuilder(this);
        }

        public Expression ToUntyped()
        {
            return this;
        }
    }
    [System.ComponentModel.DescriptionAttribute(@"This expression always returns the default value for the specified type")]
    public partial record DefaultExpression<T> : ExpressionFramework.Domain.Expression, ExpressionFramework.Domain.Contracts.ITypedExpression<T>
    {
        public DefaultExpression() : base()
        {
            System.ComponentModel.DataAnnotations.Validator.ValidateObject(this, new System.ComponentModel.DataAnnotations.ValidationContext(this, null, null), true);
        }

        public override ExpressionFramework.Domain.Builders.ExpressionBuilder ToBuilder()
        {
            return (ExpressionFramework.Domain.Builders.ExpressionBuilder)ToTypedBuilder();
        }

        public ExpressionFramework.Domain.Contracts.ITypedExpressionBuilder<T> ToTypedBuilder()
        {
            return new ExpressionFramework.Domain.Builders.Expressions.DefaultExpressionBuilder<T>(this);
        }
    }
    [System.ComponentModel.DescriptionAttribute(@"Returns a value from a delegate")]
    public partial record DelegateExpression : ExpressionFramework.Domain.Expression
    {
        [System.ComponentModel.DataAnnotations.RequiredAttribute]
        [System.ComponentModel.DescriptionAttribute(@"Delegate to use")]
        public System.Func<object?,object?> Value
        {
            get;
        }

        public DelegateExpression(System.Func<object?,object?> value) : base()
        {
            this.Value = value;
            System.ComponentModel.DataAnnotations.Validator.ValidateObject(this, new System.ComponentModel.DataAnnotations.ValidationContext(this, null, null), true);
        }

        public override ExpressionFramework.Domain.Builders.ExpressionBuilder ToBuilder()
        {
            return ToTypedBuilder();
        }

        public ExpressionFramework.Domain.Builders.Expressions.DelegateExpressionBuilder ToTypedBuilder()
        {
            return new ExpressionFramework.Domain.Builders.Expressions.DelegateExpressionBuilder(this);
        }
    }
    [System.ComponentModel.DescriptionAttribute(@"Returns a result from a delegate")]
    public partial record DelegateResultExpression : ExpressionFramework.Domain.Expression
    {
        [System.ComponentModel.DataAnnotations.RequiredAttribute]
        [System.ComponentModel.DescriptionAttribute(@"Delegate to use")]
        public System.Func<object?,CrossCutting.Common.Results.Result<object?>> Result
        {
            get;
        }

        public DelegateResultExpression(System.Func<object?,CrossCutting.Common.Results.Result<object?>> result) : base()
        {
            this.Result = result;
            System.ComponentModel.DataAnnotations.Validator.ValidateObject(this, new System.ComponentModel.DataAnnotations.ValidationContext(this, null, null), true);
        }

        public override ExpressionFramework.Domain.Builders.ExpressionBuilder ToBuilder()
        {
            return ToTypedBuilder();
        }

        public ExpressionFramework.Domain.Builders.Expressions.DelegateResultExpressionBuilder ToTypedBuilder()
        {
            return new ExpressionFramework.Domain.Builders.Expressions.DelegateResultExpressionBuilder(this);
        }
    }
    [System.ComponentModel.DescriptionAttribute(@"Gets the value at the specified index from the (enumerable) expression")]
    public partial record ElementAtExpression : ExpressionFramework.Domain.Expression
    {
        [System.ComponentModel.DataAnnotations.RequiredAttribute]
        [CrossCutting.Common.DataAnnotations.ValidateObjectAttribute]
        [System.ComponentModel.DescriptionAttribute(@"Enumerable expression to use")]
        public ExpressionFramework.Domain.Contracts.ITypedExpression<System.Collections.IEnumerable> Expression
        {
            get;
        }

        [System.ComponentModel.DataAnnotations.RequiredAttribute]
        [CrossCutting.Common.DataAnnotations.ValidateObjectAttribute]
        [System.ComponentModel.DescriptionAttribute(@"Index of the item to get")]
        public ExpressionFramework.Domain.Contracts.ITypedExpression<int> IndexExpression
        {
            get;
        }

        public ElementAtExpression(ExpressionFramework.Domain.Contracts.ITypedExpression<System.Collections.IEnumerable> expression, ExpressionFramework.Domain.Contracts.ITypedExpression<int> indexExpression) : base()
        {
            this.Expression = expression;
            this.IndexExpression = indexExpression;
            System.ComponentModel.DataAnnotations.Validator.ValidateObject(this, new System.ComponentModel.DataAnnotations.ValidationContext(this, null, null), true);
        }

        public override ExpressionFramework.Domain.Builders.ExpressionBuilder ToBuilder()
        {
            return ToTypedBuilder();
        }

        public ExpressionFramework.Domain.Builders.Expressions.ElementAtExpressionBuilder ToTypedBuilder()
        {
            return new ExpressionFramework.Domain.Builders.Expressions.ElementAtExpressionBuilder(this);
        }
    }
    [System.ComponentModel.DescriptionAttribute(@"Gets the value at the specified index from the (enumerable) expression, or default value when not found")]
    public partial record ElementAtOrDefaultExpression : ExpressionFramework.Domain.Expression
    {
        [System.ComponentModel.DataAnnotations.RequiredAttribute]
        [CrossCutting.Common.DataAnnotations.ValidateObjectAttribute]
        [System.ComponentModel.DescriptionAttribute(@"Enumerable expression to use")]
        public ExpressionFramework.Domain.Contracts.ITypedExpression<System.Collections.IEnumerable> Expression
        {
            get;
        }

        [System.ComponentModel.DataAnnotations.RequiredAttribute]
        [CrossCutting.Common.DataAnnotations.ValidateObjectAttribute]
        [System.ComponentModel.DescriptionAttribute(@"Index of the item to get")]
        public ExpressionFramework.Domain.Contracts.ITypedExpression<int> IndexExpression
        {
            get;
        }

        [CrossCutting.Common.DataAnnotations.ValidateObjectAttribute]
        [System.ComponentModel.DescriptionAttribute(@"Expression to use in case the index could not be found")]
        public ExpressionFramework.Domain.Expression? DefaultExpression
        {
            get;
        }

        public ElementAtOrDefaultExpression(ExpressionFramework.Domain.Contracts.ITypedExpression<System.Collections.IEnumerable> expression, ExpressionFramework.Domain.Contracts.ITypedExpression<int> indexExpression, ExpressionFramework.Domain.Expression? defaultExpression) : base()
        {
            this.Expression = expression;
            this.IndexExpression = indexExpression;
            this.DefaultExpression = defaultExpression;
            System.ComponentModel.DataAnnotations.Validator.ValidateObject(this, new System.ComponentModel.DataAnnotations.ValidationContext(this, null, null), true);
        }

        public override ExpressionFramework.Domain.Builders.ExpressionBuilder ToBuilder()
        {
            return ToTypedBuilder();
        }

        public ExpressionFramework.Domain.Builders.Expressions.ElementAtOrDefaultExpressionBuilder ToTypedBuilder()
        {
            return new ExpressionFramework.Domain.Builders.Expressions.ElementAtOrDefaultExpressionBuilder(this);
        }
    }
    [System.ComponentModel.DescriptionAttribute(@"This expression always returns an empty value (null)")]
    public partial record EmptyExpression : ExpressionFramework.Domain.Expression
    {
        public EmptyExpression() : base()
        {
            System.ComponentModel.DataAnnotations.Validator.ValidateObject(this, new System.ComponentModel.DataAnnotations.ValidationContext(this, null, null), true);
        }

        public override ExpressionFramework.Domain.Builders.ExpressionBuilder ToBuilder()
        {
            return ToTypedBuilder();
        }

        public ExpressionFramework.Domain.Builders.Expressions.EmptyExpressionBuilder ToTypedBuilder()
        {
            return new ExpressionFramework.Domain.Builders.Expressions.EmptyExpressionBuilder(this);
        }
    }
    [System.ComponentModel.DescriptionAttribute(@"Evaluates two expressions, and compares the two results. It will return true when they are equal, or false otherwise.")]
    public partial record EqualsExpression : ExpressionFramework.Domain.Expression, ExpressionFramework.Domain.Contracts.ITypedExpression<bool>
    {
        [System.ComponentModel.DataAnnotations.RequiredAttribute]
        [CrossCutting.Common.DataAnnotations.ValidateObjectAttribute]
        [System.ComponentModel.DescriptionAttribute(@"First expression to perform Equals operation on")]
        public ExpressionFramework.Domain.Expression FirstExpression
        {
            get;
        }

        [System.ComponentModel.DataAnnotations.RequiredAttribute]
        [CrossCutting.Common.DataAnnotations.ValidateObjectAttribute]
        [System.ComponentModel.DescriptionAttribute(@"Second expression to perform Equals operation on")]
        public ExpressionFramework.Domain.Expression SecondExpression
        {
            get;
        }

        public EqualsExpression(ExpressionFramework.Domain.Expression firstExpression, ExpressionFramework.Domain.Expression secondExpression) : base()
        {
            this.FirstExpression = firstExpression;
            this.SecondExpression = secondExpression;
            System.ComponentModel.DataAnnotations.Validator.ValidateObject(this, new System.ComponentModel.DataAnnotations.ValidationContext(this, null, null), true);
        }

        public override ExpressionFramework.Domain.Builders.ExpressionBuilder ToBuilder()
        {
            return (ExpressionFramework.Domain.Builders.ExpressionBuilder)ToTypedBuilder();
        }

        public ExpressionFramework.Domain.Contracts.ITypedExpressionBuilder<bool> ToTypedBuilder()
        {
            return new ExpressionFramework.Domain.Builders.Expressions.EqualsExpressionBuilder(this);
        }

        public Expression ToUntyped()
        {
            return this;
        }
    }
    [System.ComponentModel.DescriptionAttribute(@"Returns an error result")]
    public partial record ErrorExpression : ExpressionFramework.Domain.Expression
    {
        [System.ComponentModel.DataAnnotations.RequiredAttribute]
        [CrossCutting.Common.DataAnnotations.ValidateObjectAttribute]
        [System.ComponentModel.DescriptionAttribute(@"Error message to use")]
        public ExpressionFramework.Domain.Contracts.ITypedExpression<string> ErrorMessageExpression
        {
            get;
        }

        public ErrorExpression(ExpressionFramework.Domain.Contracts.ITypedExpression<string> errorMessageExpression) : base()
        {
            this.ErrorMessageExpression = errorMessageExpression;
            System.ComponentModel.DataAnnotations.Validator.ValidateObject(this, new System.ComponentModel.DataAnnotations.ValidationContext(this, null, null), true);
        }

        public override ExpressionFramework.Domain.Builders.ExpressionBuilder ToBuilder()
        {
            return ToTypedBuilder();
        }

        public ExpressionFramework.Domain.Builders.Expressions.ErrorExpressionBuilder ToTypedBuilder()
        {
            return new ExpressionFramework.Domain.Builders.Expressions.ErrorExpressionBuilder(this);
        }
    }
    [System.ComponentModel.DescriptionAttribute(@"Evaluates the specified condition, and returns the result")]
    public partial record EvaluatableExpression : ExpressionFramework.Domain.Expression, ExpressionFramework.Domain.Contracts.ITypedExpression<bool>
    {
        [System.ComponentModel.DataAnnotations.RequiredAttribute]
        [CrossCutting.Common.DataAnnotations.ValidateObjectAttribute]
        [System.ComponentModel.DescriptionAttribute(@"Condition to evaluate on the expression")]
        public ExpressionFramework.Domain.Evaluatable Condition
        {
            get;
        }

        [System.ComponentModel.DataAnnotations.RequiredAttribute]
        [CrossCutting.Common.DataAnnotations.ValidateObjectAttribute]
        [System.ComponentModel.DescriptionAttribute(@"Expression to use")]
        public ExpressionFramework.Domain.Expression Expression
        {
            get;
        }

        public EvaluatableExpression(ExpressionFramework.Domain.Evaluatable condition, ExpressionFramework.Domain.Expression expression) : base()
        {
            this.Condition = condition;
            this.Expression = expression;
            System.ComponentModel.DataAnnotations.Validator.ValidateObject(this, new System.ComponentModel.DataAnnotations.ValidationContext(this, null, null), true);
        }

        public override ExpressionFramework.Domain.Builders.ExpressionBuilder ToBuilder()
        {
            return (ExpressionFramework.Domain.Builders.ExpressionBuilder)ToTypedBuilder();
        }

        public ExpressionFramework.Domain.Contracts.ITypedExpressionBuilder<bool> ToTypedBuilder()
        {
            return new ExpressionFramework.Domain.Builders.Expressions.EvaluatableExpressionBuilder(this);
        }

        public Expression ToUntyped()
        {
            return this;
        }
    }
    [System.ComponentModel.DescriptionAttribute(@"Returns false")]
    public partial record FalseExpression : ExpressionFramework.Domain.Expression, ExpressionFramework.Domain.Contracts.ITypedExpression<bool>
    {
        public FalseExpression() : base()
        {
            System.ComponentModel.DataAnnotations.Validator.ValidateObject(this, new System.ComponentModel.DataAnnotations.ValidationContext(this, null, null), true);
        }

        public override ExpressionFramework.Domain.Builders.ExpressionBuilder ToBuilder()
        {
            return (ExpressionFramework.Domain.Builders.ExpressionBuilder)ToTypedBuilder();
        }

        public ExpressionFramework.Domain.Contracts.ITypedExpressionBuilder<bool> ToTypedBuilder()
        {
            return new ExpressionFramework.Domain.Builders.Expressions.FalseExpressionBuilder(this);
        }

        public Expression ToUntyped()
        {
            return this;
        }
    }
    [System.ComponentModel.DescriptionAttribute(@"Returns the value of a field (property) of the specified expression")]
    public partial record FieldExpression : ExpressionFramework.Domain.Expression
    {
        [System.ComponentModel.DataAnnotations.RequiredAttribute]
        [CrossCutting.Common.DataAnnotations.ValidateObjectAttribute]
        [System.ComponentModel.DescriptionAttribute(@"Expression to get the field (property) value for")]
        public ExpressionFramework.Domain.Expression Expression
        {
            get;
        }

        [System.ComponentModel.DataAnnotations.RequiredAttribute]
        [CrossCutting.Common.DataAnnotations.ValidateObjectAttribute]
        [System.ComponentModel.DescriptionAttribute(@"Name of the field (property). Can also be nested, like Address.Street")]
        public ExpressionFramework.Domain.Contracts.ITypedExpression<string> FieldNameExpression
        {
            get;
        }

        public FieldExpression(ExpressionFramework.Domain.Expression expression, ExpressionFramework.Domain.Contracts.ITypedExpression<string> fieldNameExpression) : base()
        {
            this.Expression = expression;
            this.FieldNameExpression = fieldNameExpression;
            System.ComponentModel.DataAnnotations.Validator.ValidateObject(this, new System.ComponentModel.DataAnnotations.ValidationContext(this, null, null), true);
        }

        public override ExpressionFramework.Domain.Builders.ExpressionBuilder ToBuilder()
        {
            return ToTypedBuilder();
        }

        public ExpressionFramework.Domain.Builders.Expressions.FieldExpressionBuilder ToTypedBuilder()
        {
            return new ExpressionFramework.Domain.Builders.Expressions.FieldExpressionBuilder(this);
        }
    }
    [System.ComponentModel.DescriptionAttribute(@"Gets the first value from the (enumerable) expression, optionally using a predicate to select an item")]
    public partial record FirstExpression : ExpressionFramework.Domain.Expression
    {
        [System.ComponentModel.DataAnnotations.RequiredAttribute]
        [CrossCutting.Common.DataAnnotations.ValidateObjectAttribute]
        [System.ComponentModel.DescriptionAttribute(@"Enumerable expression to use")]
        public ExpressionFramework.Domain.Contracts.ITypedExpression<System.Collections.IEnumerable> Expression
        {
            get;
        }

        [CrossCutting.Common.DataAnnotations.ValidateObjectAttribute]
        [System.ComponentModel.DescriptionAttribute(@"Optional predicate to use")]
        public ExpressionFramework.Domain.Contracts.ITypedExpression<bool>? PredicateExpression
        {
            get;
        }

        public FirstExpression(ExpressionFramework.Domain.Contracts.ITypedExpression<System.Collections.IEnumerable> expression, ExpressionFramework.Domain.Contracts.ITypedExpression<bool>? predicateExpression) : base()
        {
            this.Expression = expression;
            this.PredicateExpression = predicateExpression;
            System.ComponentModel.DataAnnotations.Validator.ValidateObject(this, new System.ComponentModel.DataAnnotations.ValidationContext(this, null, null), true);
        }

        public override ExpressionFramework.Domain.Builders.ExpressionBuilder ToBuilder()
        {
            return ToTypedBuilder();
        }

        public ExpressionFramework.Domain.Builders.Expressions.FirstExpressionBuilder ToTypedBuilder()
        {
            return new ExpressionFramework.Domain.Builders.Expressions.FirstExpressionBuilder(this);
        }
    }
    [System.ComponentModel.DescriptionAttribute(@"Gets the first value from the (enumerable) expression, optionally using a predicate to select an item, or default value when not found")]
    public partial record FirstOrDefaultExpression : ExpressionFramework.Domain.Expression
    {
        [System.ComponentModel.DataAnnotations.RequiredAttribute]
        [CrossCutting.Common.DataAnnotations.ValidateObjectAttribute]
        [System.ComponentModel.DescriptionAttribute(@"Enumerable expression to use")]
        public ExpressionFramework.Domain.Contracts.ITypedExpression<System.Collections.IEnumerable> Expression
        {
            get;
        }

        [CrossCutting.Common.DataAnnotations.ValidateObjectAttribute]
        [System.ComponentModel.DescriptionAttribute(@"Optional predicate to use")]
        public ExpressionFramework.Domain.Contracts.ITypedExpression<bool>? PredicateExpression
        {
            get;
        }

        [CrossCutting.Common.DataAnnotations.ValidateObjectAttribute]
        [System.ComponentModel.DescriptionAttribute(@"Expression to use in case no items of the enumerable expression match the predicate")]
        public ExpressionFramework.Domain.Expression? DefaultExpression
        {
            get;
        }

        public FirstOrDefaultExpression(ExpressionFramework.Domain.Contracts.ITypedExpression<System.Collections.IEnumerable> expression, ExpressionFramework.Domain.Contracts.ITypedExpression<bool>? predicateExpression, ExpressionFramework.Domain.Expression? defaultExpression) : base()
        {
            this.Expression = expression;
            this.PredicateExpression = predicateExpression;
            this.DefaultExpression = defaultExpression;
            System.ComponentModel.DataAnnotations.Validator.ValidateObject(this, new System.ComponentModel.DataAnnotations.ValidationContext(this, null, null), true);
        }

        public override ExpressionFramework.Domain.Builders.ExpressionBuilder ToBuilder()
        {
            return ToTypedBuilder();
        }

        public ExpressionFramework.Domain.Builders.Expressions.FirstOrDefaultExpressionBuilder ToTypedBuilder()
        {
            return new ExpressionFramework.Domain.Builders.Expressions.FirstOrDefaultExpressionBuilder(this);
        }
    }
    [System.ComponentModel.DescriptionAttribute(@"Groups items from an enumerable expression using a key selector expression")]
    public partial record GroupByExpression : ExpressionFramework.Domain.Expression
    {
        [System.ComponentModel.DataAnnotations.RequiredAttribute]
        [CrossCutting.Common.DataAnnotations.ValidateObjectAttribute]
        [System.ComponentModel.DescriptionAttribute(@"Enumerable expression to use")]
        public ExpressionFramework.Domain.Contracts.ITypedExpression<System.Collections.IEnumerable> Expression
        {
            get;
        }

        [System.ComponentModel.DataAnnotations.RequiredAttribute]
        [CrossCutting.Common.DataAnnotations.ValidateObjectAttribute]
        [System.ComponentModel.DescriptionAttribute(@"Expression to use on each item to select the key")]
        public ExpressionFramework.Domain.Expression KeySelectorExpression
        {
            get;
        }

        public GroupByExpression(ExpressionFramework.Domain.Contracts.ITypedExpression<System.Collections.IEnumerable> expression, ExpressionFramework.Domain.Expression keySelectorExpression) : base()
        {
            this.Expression = expression;
            this.KeySelectorExpression = keySelectorExpression;
            System.ComponentModel.DataAnnotations.Validator.ValidateObject(this, new System.ComponentModel.DataAnnotations.ValidationContext(this, null, null), true);
        }

        public override ExpressionFramework.Domain.Builders.ExpressionBuilder ToBuilder()
        {
            return ToTypedBuilder();
        }

        public ExpressionFramework.Domain.Builders.Expressions.GroupByExpressionBuilder ToTypedBuilder()
        {
            return new ExpressionFramework.Domain.Builders.Expressions.GroupByExpressionBuilder(this);
        }
    }
    [System.ComponentModel.DescriptionAttribute(@"Evaluates a condition")]
    public partial record IfExpression : ExpressionFramework.Domain.Expression
    {
        [System.ComponentModel.DataAnnotations.RequiredAttribute]
        [CrossCutting.Common.DataAnnotations.ValidateObjectAttribute]
        [System.ComponentModel.DescriptionAttribute(@"Condition to evaluate")]
        public ExpressionFramework.Domain.Evaluatable Condition
        {
            get;
        }

        [System.ComponentModel.DataAnnotations.RequiredAttribute]
        [CrossCutting.Common.DataAnnotations.ValidateObjectAttribute]
        [System.ComponentModel.DescriptionAttribute(@"Expression to use when the condition evaluates to true")]
        public ExpressionFramework.Domain.Expression ResultExpression
        {
            get;
        }

        [CrossCutting.Common.DataAnnotations.ValidateObjectAttribute]
        [System.ComponentModel.DescriptionAttribute(@"Optional expression to use when the condition evaluates to false. When left empty, an empty expression will be used.")]
        public ExpressionFramework.Domain.Expression? DefaultExpression
        {
            get;
        }

        public IfExpression(ExpressionFramework.Domain.Evaluatable condition, ExpressionFramework.Domain.Expression resultExpression, ExpressionFramework.Domain.Expression? defaultExpression) : base()
        {
            this.Condition = condition;
            this.ResultExpression = resultExpression;
            this.DefaultExpression = defaultExpression;
            System.ComponentModel.DataAnnotations.Validator.ValidateObject(this, new System.ComponentModel.DataAnnotations.ValidationContext(this, null, null), true);
        }

        public override ExpressionFramework.Domain.Builders.ExpressionBuilder ToBuilder()
        {
            return ToTypedBuilder();
        }

        public ExpressionFramework.Domain.Builders.Expressions.IfExpressionBuilder ToTypedBuilder()
        {
            return new ExpressionFramework.Domain.Builders.Expressions.IfExpressionBuilder(this);
        }
    }
    [System.ComponentModel.DescriptionAttribute(@"Returns an invalid result")]
    public partial record InvalidExpression : ExpressionFramework.Domain.Expression
    {
        [System.ComponentModel.DataAnnotations.RequiredAttribute(AllowEmptyStrings = true)]
        [CrossCutting.Common.DataAnnotations.ValidateObjectAttribute]
        [System.ComponentModel.DescriptionAttribute(@"Error message to use (may be empty)")]
        public ExpressionFramework.Domain.Contracts.ITypedExpression<string> ErrorMessageExpression
        {
            get;
        }

        [System.ComponentModel.DataAnnotations.RequiredAttribute]
        [CrossCutting.Common.DataAnnotations.ValidateObjectAttribute]
        [System.ComponentModel.DescriptionAttribute(@"Optional validation errors to use")]
        public System.Collections.Generic.IReadOnlyCollection<ExpressionFramework.Domain.Contracts.ITypedExpression<CrossCutting.Common.Results.ValidationError>> ValidationErrorExpressions
        {
            get;
        }

        public InvalidExpression(ExpressionFramework.Domain.Contracts.ITypedExpression<string> errorMessageExpression, System.Collections.Generic.IEnumerable<ExpressionFramework.Domain.Contracts.ITypedExpression<CrossCutting.Common.Results.ValidationError>> validationErrorExpressions) : base()
        {
            this.ErrorMessageExpression = errorMessageExpression;
            this.ValidationErrorExpressions = validationErrorExpressions is null ? null! : new CrossCutting.Common.ReadOnlyValueCollection<ExpressionFramework.Domain.Contracts.ITypedExpression<CrossCutting.Common.Results.ValidationError>>(validationErrorExpressions);
            System.ComponentModel.DataAnnotations.Validator.ValidateObject(this, new System.ComponentModel.DataAnnotations.ValidationContext(this, null, null), true);
        }

        public override ExpressionFramework.Domain.Builders.ExpressionBuilder ToBuilder()
        {
            return ToTypedBuilder();
        }

        public ExpressionFramework.Domain.Builders.Expressions.InvalidExpressionBuilder ToTypedBuilder()
        {
            return new ExpressionFramework.Domain.Builders.Expressions.InvalidExpressionBuilder(this);
        }
    }
    [System.ComponentModel.DescriptionAttribute(@"Gets the last value from the (enumerable) expression, optionally using a predicate to select an item")]
    public partial record LastExpression : ExpressionFramework.Domain.Expression
    {
        [System.ComponentModel.DataAnnotations.RequiredAttribute]
        [CrossCutting.Common.DataAnnotations.ValidateObjectAttribute]
        [System.ComponentModel.DescriptionAttribute(@"Enumerable expression to use")]
        public ExpressionFramework.Domain.Contracts.ITypedExpression<System.Collections.IEnumerable> Expression
        {
            get;
        }

        [CrossCutting.Common.DataAnnotations.ValidateObjectAttribute]
        [System.ComponentModel.DescriptionAttribute(@"Predicate to use")]
        public ExpressionFramework.Domain.Contracts.ITypedExpression<bool>? PredicateExpression
        {
            get;
        }

        public LastExpression(ExpressionFramework.Domain.Contracts.ITypedExpression<System.Collections.IEnumerable> expression, ExpressionFramework.Domain.Contracts.ITypedExpression<bool>? predicateExpression) : base()
        {
            this.Expression = expression;
            this.PredicateExpression = predicateExpression;
            System.ComponentModel.DataAnnotations.Validator.ValidateObject(this, new System.ComponentModel.DataAnnotations.ValidationContext(this, null, null), true);
        }

        public override ExpressionFramework.Domain.Builders.ExpressionBuilder ToBuilder()
        {
            return ToTypedBuilder();
        }

        public ExpressionFramework.Domain.Builders.Expressions.LastExpressionBuilder ToTypedBuilder()
        {
            return new ExpressionFramework.Domain.Builders.Expressions.LastExpressionBuilder(this);
        }
    }
    [System.ComponentModel.DescriptionAttribute(@"Gets the last value from the (enumerable) expression, optionally using a predicate to select an item, or default value when not found")]
    public partial record LastOrDefaultExpression : ExpressionFramework.Domain.Expression
    {
        [System.ComponentModel.DataAnnotations.RequiredAttribute]
        [CrossCutting.Common.DataAnnotations.ValidateObjectAttribute]
        [System.ComponentModel.DescriptionAttribute(@"Enumerable expression to use")]
        public ExpressionFramework.Domain.Contracts.ITypedExpression<System.Collections.IEnumerable> Expression
        {
            get;
        }

        [CrossCutting.Common.DataAnnotations.ValidateObjectAttribute]
        [System.ComponentModel.DescriptionAttribute(@"Optional predicate to use")]
        public ExpressionFramework.Domain.Contracts.ITypedExpression<bool>? PredicateExpression
        {
            get;
        }

        [CrossCutting.Common.DataAnnotations.ValidateObjectAttribute]
        [System.ComponentModel.DescriptionAttribute(@"Expression to use in case no items of the enumerable expression match the predicate")]
        public ExpressionFramework.Domain.Expression? DefaultExpression
        {
            get;
        }

        public LastOrDefaultExpression(ExpressionFramework.Domain.Contracts.ITypedExpression<System.Collections.IEnumerable> expression, ExpressionFramework.Domain.Contracts.ITypedExpression<bool>? predicateExpression, ExpressionFramework.Domain.Expression? defaultExpression) : base()
        {
            this.Expression = expression;
            this.PredicateExpression = predicateExpression;
            this.DefaultExpression = defaultExpression;
            System.ComponentModel.DataAnnotations.Validator.ValidateObject(this, new System.ComponentModel.DataAnnotations.ValidationContext(this, null, null), true);
        }

        public override ExpressionFramework.Domain.Builders.ExpressionBuilder ToBuilder()
        {
            return ToTypedBuilder();
        }

        public ExpressionFramework.Domain.Builders.Expressions.LastOrDefaultExpressionBuilder ToTypedBuilder()
        {
            return new ExpressionFramework.Domain.Builders.Expressions.LastOrDefaultExpressionBuilder(this);
        }
    }
    [System.ComponentModel.DescriptionAttribute(@"Gets a number of characters of the start of a string value of the specified expression")]
    public partial record LeftExpression : ExpressionFramework.Domain.Expression, ExpressionFramework.Domain.Contracts.ITypedExpression<string>
    {
        [System.ComponentModel.DataAnnotations.RequiredAttribute]
        [CrossCutting.Common.DataAnnotations.ValidateObjectAttribute]
        [System.ComponentModel.DescriptionAttribute(@"String to get the first characters for")]
        public ExpressionFramework.Domain.Contracts.ITypedExpression<string> Expression
        {
            get;
        }

        [System.ComponentModel.DataAnnotations.RequiredAttribute]
        [CrossCutting.Common.DataAnnotations.ValidateObjectAttribute]
        [System.ComponentModel.DescriptionAttribute(@"Number of characters to get")]
        public ExpressionFramework.Domain.Contracts.ITypedExpression<int> LengthExpression
        {
            get;
        }

        public LeftExpression(ExpressionFramework.Domain.Contracts.ITypedExpression<string> expression, ExpressionFramework.Domain.Contracts.ITypedExpression<int> lengthExpression) : base()
        {
            this.Expression = expression;
            this.LengthExpression = lengthExpression;
            System.ComponentModel.DataAnnotations.Validator.ValidateObject(this, new System.ComponentModel.DataAnnotations.ValidationContext(this, null, null), true);
        }

        public override ExpressionFramework.Domain.Builders.ExpressionBuilder ToBuilder()
        {
            return (ExpressionFramework.Domain.Builders.ExpressionBuilder)ToTypedBuilder();
        }

        public ExpressionFramework.Domain.Contracts.ITypedExpressionBuilder<string> ToTypedBuilder()
        {
            return new ExpressionFramework.Domain.Builders.Expressions.LeftExpressionBuilder(this);
        }

        public Expression ToUntyped()
        {
            return this;
        }
    }
    [System.ComponentModel.DescriptionAttribute(@"Gets the maximum value from the (enumerable) expression, optionally using a selector expression")]
    public partial record MaxExpression : ExpressionFramework.Domain.Expression
    {
        [System.ComponentModel.DataAnnotations.RequiredAttribute]
        [CrossCutting.Common.DataAnnotations.ValidateObjectAttribute]
        [System.ComponentModel.DescriptionAttribute(@"Enumerable expression to use")]
        public ExpressionFramework.Domain.Contracts.ITypedExpression<System.Collections.IEnumerable> Expression
        {
            get;
        }

        [CrossCutting.Common.DataAnnotations.ValidateObjectAttribute]
        [System.ComponentModel.DescriptionAttribute(@"Optional selection expression")]
        public ExpressionFramework.Domain.Expression? SelectorExpression
        {
            get;
        }

        public MaxExpression(ExpressionFramework.Domain.Contracts.ITypedExpression<System.Collections.IEnumerable> expression, ExpressionFramework.Domain.Expression? selectorExpression) : base()
        {
            this.Expression = expression;
            this.SelectorExpression = selectorExpression;
            System.ComponentModel.DataAnnotations.Validator.ValidateObject(this, new System.ComponentModel.DataAnnotations.ValidationContext(this, null, null), true);
        }

        public override ExpressionFramework.Domain.Builders.ExpressionBuilder ToBuilder()
        {
            return ToTypedBuilder();
        }

        public ExpressionFramework.Domain.Builders.Expressions.MaxExpressionBuilder ToTypedBuilder()
        {
            return new ExpressionFramework.Domain.Builders.Expressions.MaxExpressionBuilder(this);
        }
    }
    [System.ComponentModel.DescriptionAttribute(@"Gets the minimum value from the (enumerable) expression, optionally using a selector expression")]
    public partial record MinExpression : ExpressionFramework.Domain.Expression
    {
        [System.ComponentModel.DataAnnotations.RequiredAttribute]
        [CrossCutting.Common.DataAnnotations.ValidateObjectAttribute]
        [System.ComponentModel.DescriptionAttribute(@"Enumerable expression to use")]
        public ExpressionFramework.Domain.Contracts.ITypedExpression<System.Collections.IEnumerable> Expression
        {
            get;
        }

        [CrossCutting.Common.DataAnnotations.ValidateObjectAttribute]
        [System.ComponentModel.DescriptionAttribute(@"Optional selection expression")]
        public ExpressionFramework.Domain.Expression? SelectorExpression
        {
            get;
        }

        public MinExpression(ExpressionFramework.Domain.Contracts.ITypedExpression<System.Collections.IEnumerable> expression, ExpressionFramework.Domain.Expression? selectorExpression) : base()
        {
            this.Expression = expression;
            this.SelectorExpression = selectorExpression;
            System.ComponentModel.DataAnnotations.Validator.ValidateObject(this, new System.ComponentModel.DataAnnotations.ValidationContext(this, null, null), true);
        }

        public override ExpressionFramework.Domain.Builders.ExpressionBuilder ToBuilder()
        {
            return ToTypedBuilder();
        }

        public ExpressionFramework.Domain.Builders.Expressions.MinExpressionBuilder ToTypedBuilder()
        {
            return new ExpressionFramework.Domain.Builders.Expressions.MinExpressionBuilder(this);
        }
    }
    [System.ComponentModel.DescriptionAttribute(@"Returns the month from the specified DateTime expression")]
    public partial record MonthExpression : ExpressionFramework.Domain.Expression, ExpressionFramework.Domain.Contracts.ITypedExpression<int>
    {
        [System.ComponentModel.DataAnnotations.RequiredAttribute]
        [CrossCutting.Common.DataAnnotations.ValidateObjectAttribute]
        [System.ComponentModel.DescriptionAttribute(@"DateTime source expression")]
        public ExpressionFramework.Domain.Contracts.ITypedExpression<System.DateTime> Expression
        {
            get;
        }

        public MonthExpression(ExpressionFramework.Domain.Contracts.ITypedExpression<System.DateTime> expression) : base()
        {
            this.Expression = expression;
            System.ComponentModel.DataAnnotations.Validator.ValidateObject(this, new System.ComponentModel.DataAnnotations.ValidationContext(this, null, null), true);
        }

        public override ExpressionFramework.Domain.Builders.ExpressionBuilder ToBuilder()
        {
            return (ExpressionFramework.Domain.Builders.ExpressionBuilder)ToTypedBuilder();
        }

        public ExpressionFramework.Domain.Contracts.ITypedExpressionBuilder<int> ToTypedBuilder()
        {
            return new ExpressionFramework.Domain.Builders.Expressions.MonthExpressionBuilder(this);
        }

        public Expression ToUntyped()
        {
            return this;
        }
    }
    [System.ComponentModel.DescriptionAttribute(@"Evaluates two expressions, and compares the two results. It will return true when they are not equal, or false otherwise.")]
    public partial record NotEqualsExpression : ExpressionFramework.Domain.Expression, ExpressionFramework.Domain.Contracts.ITypedExpression<bool>
    {
        [System.ComponentModel.DataAnnotations.RequiredAttribute]
        [CrossCutting.Common.DataAnnotations.ValidateObjectAttribute]
        [System.ComponentModel.DescriptionAttribute(@"First expression to perform Not Equals operation on")]
        public ExpressionFramework.Domain.Expression FirstExpression
        {
            get;
        }

        [System.ComponentModel.DataAnnotations.RequiredAttribute]
        [CrossCutting.Common.DataAnnotations.ValidateObjectAttribute]
        [System.ComponentModel.DescriptionAttribute(@"Second expression to perform Not Equals operation on")]
        public ExpressionFramework.Domain.Expression SecondExpression
        {
            get;
        }

        public NotEqualsExpression(ExpressionFramework.Domain.Expression firstExpression, ExpressionFramework.Domain.Expression secondExpression) : base()
        {
            this.FirstExpression = firstExpression;
            this.SecondExpression = secondExpression;
            System.ComponentModel.DataAnnotations.Validator.ValidateObject(this, new System.ComponentModel.DataAnnotations.ValidationContext(this, null, null), true);
        }

        public override ExpressionFramework.Domain.Builders.ExpressionBuilder ToBuilder()
        {
            return (ExpressionFramework.Domain.Builders.ExpressionBuilder)ToTypedBuilder();
        }

        public ExpressionFramework.Domain.Contracts.ITypedExpressionBuilder<bool> ToTypedBuilder()
        {
            return new ExpressionFramework.Domain.Builders.Expressions.NotEqualsExpressionBuilder(this);
        }

        public Expression ToUntyped()
        {
            return this;
        }
    }
    [System.ComponentModel.DescriptionAttribute(@"Returns the inverted value of the boolean value")]
    public partial record NotExpression : ExpressionFramework.Domain.Expression, ExpressionFramework.Domain.Contracts.ITypedExpression<bool>
    {
        [System.ComponentModel.DataAnnotations.RequiredAttribute]
        [CrossCutting.Common.DataAnnotations.ValidateObjectAttribute]
        [System.ComponentModel.DescriptionAttribute(@"Boolean to invert")]
        public ExpressionFramework.Domain.Contracts.ITypedExpression<bool> Expression
        {
            get;
        }

        public NotExpression(ExpressionFramework.Domain.Contracts.ITypedExpression<bool> expression) : base()
        {
            this.Expression = expression;
            System.ComponentModel.DataAnnotations.Validator.ValidateObject(this, new System.ComponentModel.DataAnnotations.ValidationContext(this, null, null), true);
        }

        public override ExpressionFramework.Domain.Builders.ExpressionBuilder ToBuilder()
        {
            return (ExpressionFramework.Domain.Builders.ExpressionBuilder)ToTypedBuilder();
        }

        public ExpressionFramework.Domain.Contracts.ITypedExpressionBuilder<bool> ToTypedBuilder()
        {
            return new ExpressionFramework.Domain.Builders.Expressions.NotExpressionBuilder(this);
        }

        public Expression ToUntyped()
        {
            return this;
        }
    }
    [System.ComponentModel.DescriptionAttribute(@"Gets the current date and time")]
    public partial record NowExpression : ExpressionFramework.Domain.Expression, ExpressionFramework.Domain.Contracts.ITypedExpression<System.DateTime>
    {
        [System.ComponentModel.DescriptionAttribute(@"Optional provider for date time to use instead of the system clock")]
        public CrossCutting.Common.Abstractions.IDateTimeProvider? DateTimeProvider
        {
            get;
        }

        public NowExpression(CrossCutting.Common.Abstractions.IDateTimeProvider? dateTimeProvider) : base()
        {
            this.DateTimeProvider = dateTimeProvider;
            System.ComponentModel.DataAnnotations.Validator.ValidateObject(this, new System.ComponentModel.DataAnnotations.ValidationContext(this, null, null), true);
        }

        public override ExpressionFramework.Domain.Builders.ExpressionBuilder ToBuilder()
        {
            return (ExpressionFramework.Domain.Builders.ExpressionBuilder)ToTypedBuilder();
        }

        public ExpressionFramework.Domain.Contracts.ITypedExpressionBuilder<System.DateTime> ToTypedBuilder()
        {
            return new ExpressionFramework.Domain.Builders.Expressions.NowExpressionBuilder(this);
        }

        public Expression ToUntyped()
        {
            return this;
        }
    }
    [System.ComponentModel.DescriptionAttribute(@"Filters an enumerable expression on type")]
    public partial record OfTypeExpression : ExpressionFramework.Domain.Expression, ExpressionFramework.Domain.Contracts.ITypedExpression<System.Collections.Generic.IEnumerable<object?>>
    {
        [System.ComponentModel.DataAnnotations.RequiredAttribute]
        [CrossCutting.Common.DataAnnotations.ValidateObjectAttribute]
        [System.ComponentModel.DescriptionAttribute(@"Enumerable expression to use")]
        public ExpressionFramework.Domain.Contracts.ITypedExpression<System.Collections.IEnumerable> Expression
        {
            get;
        }

        [System.ComponentModel.DataAnnotations.RequiredAttribute]
        [CrossCutting.Common.DataAnnotations.ValidateObjectAttribute]
        [System.ComponentModel.DescriptionAttribute(@"Type to filter on")]
        public ExpressionFramework.Domain.Contracts.ITypedExpression<System.Type> TypeExpression
        {
            get;
        }

        public OfTypeExpression(ExpressionFramework.Domain.Contracts.ITypedExpression<System.Collections.IEnumerable> expression, ExpressionFramework.Domain.Contracts.ITypedExpression<System.Type> typeExpression) : base()
        {
            this.Expression = expression;
            this.TypeExpression = typeExpression;
            System.ComponentModel.DataAnnotations.Validator.ValidateObject(this, new System.ComponentModel.DataAnnotations.ValidationContext(this, null, null), true);
        }

        public override ExpressionFramework.Domain.Builders.ExpressionBuilder ToBuilder()
        {
            return (ExpressionFramework.Domain.Builders.ExpressionBuilder)ToTypedBuilder();
        }

        public ExpressionFramework.Domain.Contracts.ITypedExpressionBuilder<System.Collections.Generic.IEnumerable<object?>> ToTypedBuilder()
        {
            return new ExpressionFramework.Domain.Builders.Expressions.OfTypeExpressionBuilder(this);
        }

        public Expression ToUntyped()
        {
            return this;
        }
    }
    [System.ComponentModel.DescriptionAttribute(@"Evaluates an operator")]
    public partial record OperatorExpression : ExpressionFramework.Domain.Expression, ExpressionFramework.Domain.Contracts.ITypedExpression<bool>
    {
        [System.ComponentModel.DataAnnotations.RequiredAttribute]
        [CrossCutting.Common.DataAnnotations.ValidateObjectAttribute]
        [System.ComponentModel.DescriptionAttribute(@"Left expression to use on operator")]
        public ExpressionFramework.Domain.Expression LeftExpression
        {
            get;
        }

        [System.ComponentModel.DataAnnotations.RequiredAttribute]
        [CrossCutting.Common.DataAnnotations.ValidateObjectAttribute]
        [System.ComponentModel.DescriptionAttribute(@"Right expression to use on operator")]
        public ExpressionFramework.Domain.Expression RightExpression
        {
            get;
        }

        [System.ComponentModel.DataAnnotations.RequiredAttribute]
        [CrossCutting.Common.DataAnnotations.ValidateObjectAttribute]
        [System.ComponentModel.DescriptionAttribute(@"Operator to evaluate")]
        public ExpressionFramework.Domain.Operator Operator
        {
            get;
        }

        public OperatorExpression(ExpressionFramework.Domain.Expression leftExpression, ExpressionFramework.Domain.Expression rightExpression, ExpressionFramework.Domain.Operator @operator) : base()
        {
            this.LeftExpression = leftExpression;
            this.RightExpression = rightExpression;
            this.Operator = @operator;
            System.ComponentModel.DataAnnotations.Validator.ValidateObject(this, new System.ComponentModel.DataAnnotations.ValidationContext(this, null, null), true);
        }

        public override ExpressionFramework.Domain.Builders.ExpressionBuilder ToBuilder()
        {
            return (ExpressionFramework.Domain.Builders.ExpressionBuilder)ToTypedBuilder();
        }

        public ExpressionFramework.Domain.Contracts.ITypedExpressionBuilder<bool> ToTypedBuilder()
        {
            return new ExpressionFramework.Domain.Builders.Expressions.OperatorExpressionBuilder(this);
        }

        public Expression ToUntyped()
        {
            return this;
        }
    }
    [System.ComponentModel.DescriptionAttribute(@"Sorts items from an enumerable expression using sort expressions")]
    public partial record OrderByExpression : ExpressionFramework.Domain.Expression, ExpressionFramework.Domain.Contracts.ITypedExpression<System.Collections.Generic.IEnumerable<object?>>
    {
        [System.ComponentModel.DataAnnotations.RequiredAttribute]
        [CrossCutting.Common.DataAnnotations.ValidateObjectAttribute]
        [System.ComponentModel.DescriptionAttribute(@"Enumerable expression to use")]
        public ExpressionFramework.Domain.Contracts.ITypedExpression<System.Collections.IEnumerable> Expression
        {
            get;
        }

        [System.ComponentModel.DataAnnotations.RequiredAttribute]
        [CrossCutting.Common.DataAnnotations.ValidateObjectAttribute]
        public System.Collections.Generic.IReadOnlyCollection<ExpressionFramework.Domain.Contracts.ITypedExpression<ExpressionFramework.Domain.SortOrder>> SortOrderExpressions
        {
            get;
        }

        public OrderByExpression(ExpressionFramework.Domain.Contracts.ITypedExpression<System.Collections.IEnumerable> expression, System.Collections.Generic.IEnumerable<ExpressionFramework.Domain.Contracts.ITypedExpression<ExpressionFramework.Domain.SortOrder>> sortOrderExpressions) : base()
        {
            this.Expression = expression;
            this.SortOrderExpressions = sortOrderExpressions is null ? null! : new CrossCutting.Common.ReadOnlyValueCollection<ExpressionFramework.Domain.Contracts.ITypedExpression<ExpressionFramework.Domain.SortOrder>>(sortOrderExpressions);
            System.ComponentModel.DataAnnotations.Validator.ValidateObject(this, new System.ComponentModel.DataAnnotations.ValidationContext(this, null, null), true);
        }

        public override ExpressionFramework.Domain.Builders.ExpressionBuilder ToBuilder()
        {
            return (ExpressionFramework.Domain.Builders.ExpressionBuilder)ToTypedBuilder();
        }

        public ExpressionFramework.Domain.Contracts.ITypedExpressionBuilder<System.Collections.Generic.IEnumerable<object?>> ToTypedBuilder()
        {
            return new ExpressionFramework.Domain.Builders.Expressions.OrderByExpressionBuilder(this);
        }

        public Expression ToUntyped()
        {
            return this;
        }
    }
    [System.ComponentModel.DescriptionAttribute(@"Returns the OR-combination value of two boolean expressions")]
    public partial record OrExpression : ExpressionFramework.Domain.Expression, ExpressionFramework.Domain.Contracts.ITypedExpression<bool>
    {
        [System.ComponentModel.DataAnnotations.RequiredAttribute]
        [CrossCutting.Common.DataAnnotations.ValidateObjectAttribute]
        [System.ComponentModel.DescriptionAttribute(@"First boolean expression to perform OR combination on")]
        public ExpressionFramework.Domain.Contracts.ITypedExpression<bool> FirstExpression
        {
            get;
        }

        [System.ComponentModel.DataAnnotations.RequiredAttribute]
        [CrossCutting.Common.DataAnnotations.ValidateObjectAttribute]
        [System.ComponentModel.DescriptionAttribute(@"Second boolean expression to perform OR combination on")]
        public ExpressionFramework.Domain.Contracts.ITypedExpression<bool> SecondExpression
        {
            get;
        }

        public OrExpression(ExpressionFramework.Domain.Contracts.ITypedExpression<bool> firstExpression, ExpressionFramework.Domain.Contracts.ITypedExpression<bool> secondExpression) : base()
        {
            this.FirstExpression = firstExpression;
            this.SecondExpression = secondExpression;
            System.ComponentModel.DataAnnotations.Validator.ValidateObject(this, new System.ComponentModel.DataAnnotations.ValidationContext(this, null, null), true);
        }

        public override ExpressionFramework.Domain.Builders.ExpressionBuilder ToBuilder()
        {
            return (ExpressionFramework.Domain.Builders.ExpressionBuilder)ToTypedBuilder();
        }

        public ExpressionFramework.Domain.Contracts.ITypedExpressionBuilder<bool> ToTypedBuilder()
        {
            return new ExpressionFramework.Domain.Builders.Expressions.OrExpressionBuilder(this);
        }

        public Expression ToUntyped()
        {
            return this;
        }
    }
    [System.ComponentModel.DescriptionAttribute(@"Gets a number of characters of the end of a string value of the specified expression")]
    public partial record RightExpression : ExpressionFramework.Domain.Expression, ExpressionFramework.Domain.Contracts.ITypedExpression<string>
    {
        [System.ComponentModel.DataAnnotations.RequiredAttribute]
        [CrossCutting.Common.DataAnnotations.ValidateObjectAttribute]
        [System.ComponentModel.DescriptionAttribute(@"String to get the last characters for")]
        public ExpressionFramework.Domain.Contracts.ITypedExpression<string> Expression
        {
            get;
        }

        [System.ComponentModel.DataAnnotations.RequiredAttribute]
        [CrossCutting.Common.DataAnnotations.ValidateObjectAttribute]
        [System.ComponentModel.DescriptionAttribute(@"Number of characters to get")]
        public ExpressionFramework.Domain.Contracts.ITypedExpression<int> LengthExpression
        {
            get;
        }

        public RightExpression(ExpressionFramework.Domain.Contracts.ITypedExpression<string> expression, ExpressionFramework.Domain.Contracts.ITypedExpression<int> lengthExpression) : base()
        {
            this.Expression = expression;
            this.LengthExpression = lengthExpression;
            System.ComponentModel.DataAnnotations.Validator.ValidateObject(this, new System.ComponentModel.DataAnnotations.ValidationContext(this, null, null), true);
        }

        public override ExpressionFramework.Domain.Builders.ExpressionBuilder ToBuilder()
        {
            return (ExpressionFramework.Domain.Builders.ExpressionBuilder)ToTypedBuilder();
        }

        public ExpressionFramework.Domain.Contracts.ITypedExpressionBuilder<string> ToTypedBuilder()
        {
            return new ExpressionFramework.Domain.Builders.Expressions.RightExpressionBuilder(this);
        }

        public Expression ToUntyped()
        {
            return this;
        }
    }
    [System.ComponentModel.DescriptionAttribute(@"Transforms items from an enumerable expression using an expression")]
    public partial record SelectExpression : ExpressionFramework.Domain.Expression, ExpressionFramework.Domain.Contracts.ITypedExpression<System.Collections.Generic.IEnumerable<object?>>
    {
        [System.ComponentModel.DataAnnotations.RequiredAttribute]
        [CrossCutting.Common.DataAnnotations.ValidateObjectAttribute]
        [System.ComponentModel.DescriptionAttribute(@"Enumerable expression to use")]
        public ExpressionFramework.Domain.Contracts.ITypedExpression<System.Collections.IEnumerable> Expression
        {
            get;
        }

        [System.ComponentModel.DataAnnotations.RequiredAttribute]
        [CrossCutting.Common.DataAnnotations.ValidateObjectAttribute]
        [System.ComponentModel.DescriptionAttribute(@"Selector expression to use on each item")]
        public ExpressionFramework.Domain.Expression SelectorExpression
        {
            get;
        }

        public SelectExpression(ExpressionFramework.Domain.Contracts.ITypedExpression<System.Collections.IEnumerable> expression, ExpressionFramework.Domain.Expression selectorExpression) : base()
        {
            this.Expression = expression;
            this.SelectorExpression = selectorExpression;
            System.ComponentModel.DataAnnotations.Validator.ValidateObject(this, new System.ComponentModel.DataAnnotations.ValidationContext(this, null, null), true);
        }

        public override ExpressionFramework.Domain.Builders.ExpressionBuilder ToBuilder()
        {
            return (ExpressionFramework.Domain.Builders.ExpressionBuilder)ToTypedBuilder();
        }

        public ExpressionFramework.Domain.Contracts.ITypedExpressionBuilder<System.Collections.Generic.IEnumerable<object?>> ToTypedBuilder()
        {
            return new ExpressionFramework.Domain.Builders.Expressions.SelectExpressionBuilder(this);
        }

        public Expression ToUntyped()
        {
            return this;
        }
    }
    [System.ComponentModel.DescriptionAttribute(@"Returns all supplied expressions into a sequence (enumerable)")]
    public partial record SequenceExpression : ExpressionFramework.Domain.Expression, ExpressionFramework.Domain.Contracts.ITypedExpression<System.Collections.Generic.IEnumerable<object?>>
    {
        [System.ComponentModel.DataAnnotations.RequiredAttribute]
        [CrossCutting.Common.DataAnnotations.ValidateObjectAttribute]
        [System.ComponentModel.DescriptionAttribute(@"Expressions to put in a sequence (enumerable)")]
        public System.Collections.Generic.IReadOnlyCollection<ExpressionFramework.Domain.Expression> Expressions
        {
            get;
        }

        public SequenceExpression(System.Collections.Generic.IEnumerable<ExpressionFramework.Domain.Expression> expressions) : base()
        {
            this.Expressions = expressions is null ? null! : new CrossCutting.Common.ReadOnlyValueCollection<ExpressionFramework.Domain.Expression>(expressions);
            System.ComponentModel.DataAnnotations.Validator.ValidateObject(this, new System.ComponentModel.DataAnnotations.ValidationContext(this, null, null), true);
        }

        public override ExpressionFramework.Domain.Builders.ExpressionBuilder ToBuilder()
        {
            return (ExpressionFramework.Domain.Builders.ExpressionBuilder)ToTypedBuilder();
        }

        public ExpressionFramework.Domain.Contracts.ITypedExpressionBuilder<System.Collections.Generic.IEnumerable<object?>> ToTypedBuilder()
        {
            return new ExpressionFramework.Domain.Builders.Expressions.SequenceExpressionBuilder(this);
        }

        public Expression ToUntyped()
        {
            return this;
        }
    }
    [System.ComponentModel.DescriptionAttribute(@"Gets a single value from the (enumerable) expression, optionally using a predicate to select an item")]
    public partial record SingleExpression : ExpressionFramework.Domain.Expression
    {
        [System.ComponentModel.DataAnnotations.RequiredAttribute]
        [CrossCutting.Common.DataAnnotations.ValidateObjectAttribute]
        [System.ComponentModel.DescriptionAttribute(@"Enumerable expression to use")]
        public ExpressionFramework.Domain.Contracts.ITypedExpression<System.Collections.IEnumerable> Expression
        {
            get;
        }

        [CrossCutting.Common.DataAnnotations.ValidateObjectAttribute]
        [System.ComponentModel.DescriptionAttribute(@"Optional predicate to use")]
        public ExpressionFramework.Domain.Contracts.ITypedExpression<bool>? PredicateExpression
        {
            get;
        }

        public SingleExpression(ExpressionFramework.Domain.Contracts.ITypedExpression<System.Collections.IEnumerable> expression, ExpressionFramework.Domain.Contracts.ITypedExpression<bool>? predicateExpression) : base()
        {
            this.Expression = expression;
            this.PredicateExpression = predicateExpression;
            System.ComponentModel.DataAnnotations.Validator.ValidateObject(this, new System.ComponentModel.DataAnnotations.ValidationContext(this, null, null), true);
        }

        public override ExpressionFramework.Domain.Builders.ExpressionBuilder ToBuilder()
        {
            return ToTypedBuilder();
        }

        public ExpressionFramework.Domain.Builders.Expressions.SingleExpressionBuilder ToTypedBuilder()
        {
            return new ExpressionFramework.Domain.Builders.Expressions.SingleExpressionBuilder(this);
        }
    }
    [System.ComponentModel.DescriptionAttribute(@"Gets a single value from the (enumerable) expression, optionally using a predicate to select an item, or default value when not found")]
    public partial record SingleOrDefaultExpression : ExpressionFramework.Domain.Expression
    {
        [System.ComponentModel.DataAnnotations.RequiredAttribute]
        [CrossCutting.Common.DataAnnotations.ValidateObjectAttribute]
        [System.ComponentModel.DescriptionAttribute(@"Enumerable expression to use")]
        public ExpressionFramework.Domain.Contracts.ITypedExpression<System.Collections.IEnumerable> Expression
        {
            get;
        }

        [CrossCutting.Common.DataAnnotations.ValidateObjectAttribute]
        [System.ComponentModel.DescriptionAttribute(@"Optional predicate to use")]
        public ExpressionFramework.Domain.Contracts.ITypedExpression<bool>? PredicateExpression
        {
            get;
        }

        [CrossCutting.Common.DataAnnotations.ValidateObjectAttribute]
        [System.ComponentModel.DescriptionAttribute(@"Expression to use in case no items of the enumerable expression match the predicate")]
        public ExpressionFramework.Domain.Expression? DefaultExpression
        {
            get;
        }

        public SingleOrDefaultExpression(ExpressionFramework.Domain.Contracts.ITypedExpression<System.Collections.IEnumerable> expression, ExpressionFramework.Domain.Contracts.ITypedExpression<bool>? predicateExpression, ExpressionFramework.Domain.Expression? defaultExpression) : base()
        {
            this.Expression = expression;
            this.PredicateExpression = predicateExpression;
            this.DefaultExpression = defaultExpression;
            System.ComponentModel.DataAnnotations.Validator.ValidateObject(this, new System.ComponentModel.DataAnnotations.ValidationContext(this, null, null), true);
        }

        public override ExpressionFramework.Domain.Builders.ExpressionBuilder ToBuilder()
        {
            return ToTypedBuilder();
        }

        public ExpressionFramework.Domain.Builders.Expressions.SingleOrDefaultExpressionBuilder ToTypedBuilder()
        {
            return new ExpressionFramework.Domain.Builders.Expressions.SingleOrDefaultExpressionBuilder(this);
        }
    }
    [System.ComponentModel.DescriptionAttribute(@"Skips a number of items on an enumerable expression")]
    public partial record SkipExpression : ExpressionFramework.Domain.Expression, ExpressionFramework.Domain.Contracts.ITypedExpression<System.Collections.Generic.IEnumerable<object?>>
    {
        [System.ComponentModel.DataAnnotations.RequiredAttribute]
        [CrossCutting.Common.DataAnnotations.ValidateObjectAttribute]
        [System.ComponentModel.DescriptionAttribute(@"Enumerable expression to use")]
        public ExpressionFramework.Domain.Contracts.ITypedExpression<System.Collections.IEnumerable> Expression
        {
            get;
        }

        [System.ComponentModel.DataAnnotations.RequiredAttribute]
        [CrossCutting.Common.DataAnnotations.ValidateObjectAttribute]
        [System.ComponentModel.DescriptionAttribute(@"Number of items to skip")]
        public ExpressionFramework.Domain.Contracts.ITypedExpression<int> CountExpression
        {
            get;
        }

        public SkipExpression(ExpressionFramework.Domain.Contracts.ITypedExpression<System.Collections.IEnumerable> expression, ExpressionFramework.Domain.Contracts.ITypedExpression<int> countExpression) : base()
        {
            this.Expression = expression;
            this.CountExpression = countExpression;
            System.ComponentModel.DataAnnotations.Validator.ValidateObject(this, new System.ComponentModel.DataAnnotations.ValidationContext(this, null, null), true);
        }

        public override ExpressionFramework.Domain.Builders.ExpressionBuilder ToBuilder()
        {
            return (ExpressionFramework.Domain.Builders.ExpressionBuilder)ToTypedBuilder();
        }

        public ExpressionFramework.Domain.Contracts.ITypedExpressionBuilder<System.Collections.Generic.IEnumerable<object?>> ToTypedBuilder()
        {
            return new ExpressionFramework.Domain.Builders.Expressions.SkipExpressionBuilder(this);
        }

        public Expression ToUntyped()
        {
            return this;
        }
    }
    [System.ComponentModel.DescriptionAttribute(@"Concatenates strings")]
    public partial record StringConcatenateExpression : ExpressionFramework.Domain.Expression, ExpressionFramework.Domain.Contracts.ITypedExpression<string>
    {
        [System.ComponentModel.DataAnnotations.RequiredAttribute]
        [CrossCutting.Common.DataAnnotations.ValidateObjectAttribute]
        [System.ComponentModel.DescriptionAttribute(@"Strings to concatenate")]
        public System.Collections.Generic.IReadOnlyCollection<ExpressionFramework.Domain.Contracts.ITypedExpression<string>> Expressions
        {
            get;
        }

        public StringConcatenateExpression(System.Collections.Generic.IEnumerable<ExpressionFramework.Domain.Contracts.ITypedExpression<string>> expressions) : base()
        {
            this.Expressions = expressions is null ? null! : new CrossCutting.Common.ReadOnlyValueCollection<ExpressionFramework.Domain.Contracts.ITypedExpression<System.String>>(expressions);
            System.ComponentModel.DataAnnotations.Validator.ValidateObject(this, new System.ComponentModel.DataAnnotations.ValidationContext(this, null, null), true);
        }

        public override ExpressionFramework.Domain.Builders.ExpressionBuilder ToBuilder()
        {
            return (ExpressionFramework.Domain.Builders.ExpressionBuilder)ToTypedBuilder();
        }

        public ExpressionFramework.Domain.Contracts.ITypedExpressionBuilder<string> ToTypedBuilder()
        {
            return new ExpressionFramework.Domain.Builders.Expressions.StringConcatenateExpressionBuilder(this);
        }

        public Expression ToUntyped()
        {
            return this;
        }
    }
    [System.ComponentModel.DescriptionAttribute(@"Returns the position of the find expression within the (string) expression")]
    public partial record StringFindExpression : ExpressionFramework.Domain.Expression, ExpressionFramework.Domain.Contracts.ITypedExpression<int>
    {
        [System.ComponentModel.DataAnnotations.RequiredAttribute]
        [CrossCutting.Common.DataAnnotations.ValidateObjectAttribute]
        [System.ComponentModel.DescriptionAttribute(@"String to find text in")]
        public ExpressionFramework.Domain.Contracts.ITypedExpression<string> Expression
        {
            get;
        }

        [System.ComponentModel.DataAnnotations.RequiredAttribute]
        [CrossCutting.Common.DataAnnotations.ValidateObjectAttribute]
        [System.ComponentModel.DescriptionAttribute(@"String to find")]
        public ExpressionFramework.Domain.Contracts.ITypedExpression<string> FindExpression
        {
            get;
        }

        public StringFindExpression(ExpressionFramework.Domain.Contracts.ITypedExpression<string> expression, ExpressionFramework.Domain.Contracts.ITypedExpression<string> findExpression) : base()
        {
            this.Expression = expression;
            this.FindExpression = findExpression;
            System.ComponentModel.DataAnnotations.Validator.ValidateObject(this, new System.ComponentModel.DataAnnotations.ValidationContext(this, null, null), true);
        }

        public override ExpressionFramework.Domain.Builders.ExpressionBuilder ToBuilder()
        {
            return (ExpressionFramework.Domain.Builders.ExpressionBuilder)ToTypedBuilder();
        }

        public ExpressionFramework.Domain.Contracts.ITypedExpressionBuilder<int> ToTypedBuilder()
        {
            return new ExpressionFramework.Domain.Builders.Expressions.StringFindExpressionBuilder(this);
        }

        public Expression ToUntyped()
        {
            return this;
        }
    }
    [System.ComponentModel.DescriptionAttribute(@"Returns the length of the (string) expression")]
    public partial record StringLengthExpression : ExpressionFramework.Domain.Expression, ExpressionFramework.Domain.Contracts.ITypedExpression<int>
    {
        [System.ComponentModel.DataAnnotations.RequiredAttribute]
        [CrossCutting.Common.DataAnnotations.ValidateObjectAttribute]
        [System.ComponentModel.DescriptionAttribute(@"String to get the length for")]
        public ExpressionFramework.Domain.Contracts.ITypedExpression<string> Expression
        {
            get;
        }

        public StringLengthExpression(ExpressionFramework.Domain.Contracts.ITypedExpression<string> expression) : base()
        {
            this.Expression = expression;
            System.ComponentModel.DataAnnotations.Validator.ValidateObject(this, new System.ComponentModel.DataAnnotations.ValidationContext(this, null, null), true);
        }

        public override ExpressionFramework.Domain.Builders.ExpressionBuilder ToBuilder()
        {
            return (ExpressionFramework.Domain.Builders.ExpressionBuilder)ToTypedBuilder();
        }

        public ExpressionFramework.Domain.Contracts.ITypedExpressionBuilder<int> ToTypedBuilder()
        {
            return new ExpressionFramework.Domain.Builders.Expressions.StringLengthExpressionBuilder(this);
        }

        public Expression ToUntyped()
        {
            return this;
        }
    }
    [System.ComponentModel.DescriptionAttribute(@"Returns the position of the find expression within the (string) expression")]
    public partial record StringReplaceExpression : ExpressionFramework.Domain.Expression, ExpressionFramework.Domain.Contracts.ITypedExpression<string>
    {
        [System.ComponentModel.DataAnnotations.RequiredAttribute]
        [CrossCutting.Common.DataAnnotations.ValidateObjectAttribute]
        [System.ComponentModel.DescriptionAttribute(@"String to find text in")]
        public ExpressionFramework.Domain.Contracts.ITypedExpression<string> Expression
        {
            get;
        }

        [System.ComponentModel.DataAnnotations.RequiredAttribute]
        [CrossCutting.Common.DataAnnotations.ValidateObjectAttribute]
        [System.ComponentModel.DescriptionAttribute(@"String to find")]
        public ExpressionFramework.Domain.Contracts.ITypedExpression<string> FindExpression
        {
            get;
        }

        [System.ComponentModel.DataAnnotations.RequiredAttribute]
        [CrossCutting.Common.DataAnnotations.ValidateObjectAttribute]
        [System.ComponentModel.DescriptionAttribute(@"String to replace the found text with")]
        public ExpressionFramework.Domain.Contracts.ITypedExpression<string> ReplaceExpression
        {
            get;
        }

        public StringReplaceExpression(ExpressionFramework.Domain.Contracts.ITypedExpression<string> expression, ExpressionFramework.Domain.Contracts.ITypedExpression<string> findExpression, ExpressionFramework.Domain.Contracts.ITypedExpression<string> replaceExpression) : base()
        {
            this.Expression = expression;
            this.FindExpression = findExpression;
            this.ReplaceExpression = replaceExpression;
            System.ComponentModel.DataAnnotations.Validator.ValidateObject(this, new System.ComponentModel.DataAnnotations.ValidationContext(this, null, null), true);
        }

        public override ExpressionFramework.Domain.Builders.ExpressionBuilder ToBuilder()
        {
            return (ExpressionFramework.Domain.Builders.ExpressionBuilder)ToTypedBuilder();
        }

        public ExpressionFramework.Domain.Contracts.ITypedExpressionBuilder<string> ToTypedBuilder()
        {
            return new ExpressionFramework.Domain.Builders.Expressions.StringReplaceExpressionBuilder(this);
        }

        public Expression ToUntyped()
        {
            return this;
        }
    }
    [System.ComponentModel.DescriptionAttribute(@"Gets a number of characters from the specified position of a string value of the specified expression")]
    public partial record SubstringExpression : ExpressionFramework.Domain.Expression, ExpressionFramework.Domain.Contracts.ITypedExpression<string>
    {
        [System.ComponentModel.DataAnnotations.RequiredAttribute]
        [CrossCutting.Common.DataAnnotations.ValidateObjectAttribute]
        [System.ComponentModel.DescriptionAttribute(@"String to get characters from")]
        public ExpressionFramework.Domain.Contracts.ITypedExpression<string> Expression
        {
            get;
        }

        [System.ComponentModel.DataAnnotations.RequiredAttribute]
        [CrossCutting.Common.DataAnnotations.ValidateObjectAttribute]
        [System.ComponentModel.DescriptionAttribute(@"Zero-based start position of the characters to return")]
        public ExpressionFramework.Domain.Contracts.ITypedExpression<int> IndexExpression
        {
            get;
        }

        [CrossCutting.Common.DataAnnotations.ValidateObjectAttribute]
        [System.ComponentModel.DescriptionAttribute(@"Number of characters to use")]
        public ExpressionFramework.Domain.Contracts.ITypedExpression<int>? LengthExpression
        {
            get;
        }

        public SubstringExpression(ExpressionFramework.Domain.Contracts.ITypedExpression<string> expression, ExpressionFramework.Domain.Contracts.ITypedExpression<int> indexExpression, ExpressionFramework.Domain.Contracts.ITypedExpression<int>? lengthExpression) : base()
        {
            this.Expression = expression;
            this.IndexExpression = indexExpression;
            this.LengthExpression = lengthExpression;
            System.ComponentModel.DataAnnotations.Validator.ValidateObject(this, new System.ComponentModel.DataAnnotations.ValidationContext(this, null, null), true);
        }

        public override ExpressionFramework.Domain.Builders.ExpressionBuilder ToBuilder()
        {
            return (ExpressionFramework.Domain.Builders.ExpressionBuilder)ToTypedBuilder();
        }

        public ExpressionFramework.Domain.Contracts.ITypedExpressionBuilder<string> ToTypedBuilder()
        {
            return new ExpressionFramework.Domain.Builders.Expressions.SubstringExpressionBuilder(this);
        }

        public Expression ToUntyped()
        {
            return this;
        }
    }
    [System.ComponentModel.DescriptionAttribute(@"Gets the sum from the (enumerable) expression, optionally using a selector expression")]
    public partial record SumExpression : ExpressionFramework.Domain.Expression
    {
        [System.ComponentModel.DataAnnotations.RequiredAttribute]
        [CrossCutting.Common.DataAnnotations.ValidateObjectAttribute]
        [System.ComponentModel.DescriptionAttribute(@"Enumerable expression to use")]
        public ExpressionFramework.Domain.Contracts.ITypedExpression<System.Collections.IEnumerable> Expression
        {
            get;
        }

        [CrossCutting.Common.DataAnnotations.ValidateObjectAttribute]
        [System.ComponentModel.DescriptionAttribute(@"Optional selection expression")]
        public ExpressionFramework.Domain.Expression? SelectorExpression
        {
            get;
        }

        public SumExpression(ExpressionFramework.Domain.Contracts.ITypedExpression<System.Collections.IEnumerable> expression, ExpressionFramework.Domain.Expression? selectorExpression) : base()
        {
            this.Expression = expression;
            this.SelectorExpression = selectorExpression;
            System.ComponentModel.DataAnnotations.Validator.ValidateObject(this, new System.ComponentModel.DataAnnotations.ValidationContext(this, null, null), true);
        }

        public override ExpressionFramework.Domain.Builders.ExpressionBuilder ToBuilder()
        {
            return ToTypedBuilder();
        }

        public ExpressionFramework.Domain.Builders.Expressions.SumExpressionBuilder ToTypedBuilder()
        {
            return new ExpressionFramework.Domain.Builders.Expressions.SumExpressionBuilder(this);
        }
    }
    [System.ComponentModel.DescriptionAttribute(@"Evaluates a set of cases, and returns the result of the first valid case")]
    public partial record SwitchExpression : ExpressionFramework.Domain.Expression
    {
        [System.ComponentModel.DataAnnotations.RequiredAttribute]
        [CrossCutting.Common.DataAnnotations.ValidateObjectAttribute]
        [System.ComponentModel.DescriptionAttribute(@"Set of cases (scenarios)")]
        public System.Collections.Generic.IReadOnlyCollection<ExpressionFramework.Domain.Case> Cases
        {
            get;
        }

        [CrossCutting.Common.DataAnnotations.ValidateObjectAttribute]
        [System.ComponentModel.DescriptionAttribute(@"Optional expression to use when none of the cases evaluates to false. When left empty, an empty expression will be used.")]
        public ExpressionFramework.Domain.Expression? DefaultExpression
        {
            get;
        }

        public SwitchExpression(System.Collections.Generic.IEnumerable<ExpressionFramework.Domain.Case> cases, ExpressionFramework.Domain.Expression? defaultExpression) : base()
        {
            this.Cases = cases is null ? null! : new CrossCutting.Common.ReadOnlyValueCollection<ExpressionFramework.Domain.Case>(cases);
            this.DefaultExpression = defaultExpression;
            System.ComponentModel.DataAnnotations.Validator.ValidateObject(this, new System.ComponentModel.DataAnnotations.ValidationContext(this, null, null), true);
        }

        public override ExpressionFramework.Domain.Builders.ExpressionBuilder ToBuilder()
        {
            return ToTypedBuilder();
        }

        public ExpressionFramework.Domain.Builders.Expressions.SwitchExpressionBuilder ToTypedBuilder()
        {
            return new ExpressionFramework.Domain.Builders.Expressions.SwitchExpressionBuilder(this);
        }
    }
    [System.ComponentModel.DescriptionAttribute(@"Takes a number of items from an enumerable expression")]
    public partial record TakeExpression : ExpressionFramework.Domain.Expression, ExpressionFramework.Domain.Contracts.ITypedExpression<System.Collections.Generic.IEnumerable<object?>>
    {
        [System.ComponentModel.DataAnnotations.RequiredAttribute]
        [CrossCutting.Common.DataAnnotations.ValidateObjectAttribute]
        [System.ComponentModel.DescriptionAttribute(@"Enumerable expression to use")]
        public ExpressionFramework.Domain.Contracts.ITypedExpression<System.Collections.IEnumerable> Expression
        {
            get;
        }

        [System.ComponentModel.DataAnnotations.RequiredAttribute]
        [CrossCutting.Common.DataAnnotations.ValidateObjectAttribute]
        [System.ComponentModel.DescriptionAttribute(@"Number of items to take")]
        public ExpressionFramework.Domain.Contracts.ITypedExpression<int> CountExpression
        {
            get;
        }

        public TakeExpression(ExpressionFramework.Domain.Contracts.ITypedExpression<System.Collections.IEnumerable> expression, ExpressionFramework.Domain.Contracts.ITypedExpression<int> countExpression) : base()
        {
            this.Expression = expression;
            this.CountExpression = countExpression;
            System.ComponentModel.DataAnnotations.Validator.ValidateObject(this, new System.ComponentModel.DataAnnotations.ValidationContext(this, null, null), true);
        }

        public override ExpressionFramework.Domain.Builders.ExpressionBuilder ToBuilder()
        {
            return (ExpressionFramework.Domain.Builders.ExpressionBuilder)ToTypedBuilder();
        }

        public ExpressionFramework.Domain.Contracts.ITypedExpressionBuilder<System.Collections.Generic.IEnumerable<object?>> ToTypedBuilder()
        {
            return new ExpressionFramework.Domain.Builders.Expressions.TakeExpressionBuilder(this);
        }

        public Expression ToUntyped()
        {
            return this;
        }
    }
    [System.ComponentModel.DescriptionAttribute(@"Converts the expression to camel case")]
    public partial record ToCamelCaseExpression : ExpressionFramework.Domain.Expression, ExpressionFramework.Domain.Contracts.ITypedExpression<string>
    {
        [System.ComponentModel.DataAnnotations.RequiredAttribute]
        [CrossCutting.Common.DataAnnotations.ValidateObjectAttribute]
        [System.ComponentModel.DescriptionAttribute(@"String to get the camel case for")]
        public ExpressionFramework.Domain.Contracts.ITypedExpression<string> Expression
        {
            get;
        }

        [System.ComponentModel.DescriptionAttribute(@"Optional CultureInfo to use")]
        public ExpressionFramework.Domain.Contracts.ITypedExpression<System.Globalization.CultureInfo>? Culture
        {
            get;
        }

        public ToCamelCaseExpression(ExpressionFramework.Domain.Contracts.ITypedExpression<string> expression, ExpressionFramework.Domain.Contracts.ITypedExpression<System.Globalization.CultureInfo>? culture) : base()
        {
            this.Expression = expression;
            this.Culture = culture;
            System.ComponentModel.DataAnnotations.Validator.ValidateObject(this, new System.ComponentModel.DataAnnotations.ValidationContext(this, null, null), true);
        }

        public override ExpressionFramework.Domain.Builders.ExpressionBuilder ToBuilder()
        {
            return (ExpressionFramework.Domain.Builders.ExpressionBuilder)ToTypedBuilder();
        }

        public ExpressionFramework.Domain.Contracts.ITypedExpressionBuilder<string> ToTypedBuilder()
        {
            return new ExpressionFramework.Domain.Builders.Expressions.ToCamelCaseExpressionBuilder(this);
        }

        public Expression ToUntyped()
        {
            return this;
        }
    }
    [System.ComponentModel.DescriptionAttribute(@"Gets the current date")]
    public partial record TodayExpression : ExpressionFramework.Domain.Expression, ExpressionFramework.Domain.Contracts.ITypedExpression<System.DateTime>
    {
        [System.ComponentModel.DescriptionAttribute(@"Optional provider for date time to use instead of the system clock")]
        public CrossCutting.Common.Abstractions.IDateTimeProvider? DateTimeProvider
        {
            get;
        }

        public TodayExpression(CrossCutting.Common.Abstractions.IDateTimeProvider? dateTimeProvider) : base()
        {
            this.DateTimeProvider = dateTimeProvider;
            System.ComponentModel.DataAnnotations.Validator.ValidateObject(this, new System.ComponentModel.DataAnnotations.ValidationContext(this, null, null), true);
        }

        public override ExpressionFramework.Domain.Builders.ExpressionBuilder ToBuilder()
        {
            return (ExpressionFramework.Domain.Builders.ExpressionBuilder)ToTypedBuilder();
        }

        public ExpressionFramework.Domain.Contracts.ITypedExpressionBuilder<System.DateTime> ToTypedBuilder()
        {
            return new ExpressionFramework.Domain.Builders.Expressions.TodayExpressionBuilder(this);
        }

        public Expression ToUntyped()
        {
            return this;
        }
    }
    [System.ComponentModel.DescriptionAttribute(@"Converts the expression to lower case")]
    public partial record ToLowerCaseExpression : ExpressionFramework.Domain.Expression, ExpressionFramework.Domain.Contracts.ITypedExpression<string>
    {
        [System.ComponentModel.DataAnnotations.RequiredAttribute]
        [CrossCutting.Common.DataAnnotations.ValidateObjectAttribute]
        [System.ComponentModel.DescriptionAttribute(@"String to get the lower case for")]
        public ExpressionFramework.Domain.Contracts.ITypedExpression<string> Expression
        {
            get;
        }

        [System.ComponentModel.DescriptionAttribute(@"Optional CultureInfo to use")]
        public ExpressionFramework.Domain.Contracts.ITypedExpression<System.Globalization.CultureInfo>? Culture
        {
            get;
        }

        public ToLowerCaseExpression(ExpressionFramework.Domain.Contracts.ITypedExpression<string> expression, ExpressionFramework.Domain.Contracts.ITypedExpression<System.Globalization.CultureInfo>? culture) : base()
        {
            this.Expression = expression;
            this.Culture = culture;
            System.ComponentModel.DataAnnotations.Validator.ValidateObject(this, new System.ComponentModel.DataAnnotations.ValidationContext(this, null, null), true);
        }

        public override ExpressionFramework.Domain.Builders.ExpressionBuilder ToBuilder()
        {
            return (ExpressionFramework.Domain.Builders.ExpressionBuilder)ToTypedBuilder();
        }

        public ExpressionFramework.Domain.Contracts.ITypedExpressionBuilder<string> ToTypedBuilder()
        {
            return new ExpressionFramework.Domain.Builders.Expressions.ToLowerCaseExpressionBuilder(this);
        }

        public Expression ToUntyped()
        {
            return this;
        }
    }
    [System.ComponentModel.DescriptionAttribute(@"Converts the expression to pascal case")]
    public partial record ToPascalCaseExpression : ExpressionFramework.Domain.Expression, ExpressionFramework.Domain.Contracts.ITypedExpression<string>
    {
        [System.ComponentModel.DataAnnotations.RequiredAttribute]
        [CrossCutting.Common.DataAnnotations.ValidateObjectAttribute]
        [System.ComponentModel.DescriptionAttribute(@"String to get the pascal case for")]
        public ExpressionFramework.Domain.Contracts.ITypedExpression<string> Expression
        {
            get;
        }

        [System.ComponentModel.DescriptionAttribute(@"Optional CultureInfo to use")]
        public ExpressionFramework.Domain.Contracts.ITypedExpression<System.Globalization.CultureInfo>? Culture
        {
            get;
        }

        public ToPascalCaseExpression(ExpressionFramework.Domain.Contracts.ITypedExpression<string> expression, ExpressionFramework.Domain.Contracts.ITypedExpression<System.Globalization.CultureInfo>? culture) : base()
        {
            this.Expression = expression;
            this.Culture = culture;
            System.ComponentModel.DataAnnotations.Validator.ValidateObject(this, new System.ComponentModel.DataAnnotations.ValidationContext(this, null, null), true);
        }

        public override ExpressionFramework.Domain.Builders.ExpressionBuilder ToBuilder()
        {
            return (ExpressionFramework.Domain.Builders.ExpressionBuilder)ToTypedBuilder();
        }

        public ExpressionFramework.Domain.Contracts.ITypedExpressionBuilder<string> ToTypedBuilder()
        {
            return new ExpressionFramework.Domain.Builders.Expressions.ToPascalCaseExpressionBuilder(this);
        }

        public Expression ToUntyped()
        {
            return this;
        }
    }
    [System.ComponentModel.DescriptionAttribute(@"Converts the expression to upper case")]
    public partial record ToUpperCaseExpression : ExpressionFramework.Domain.Expression, ExpressionFramework.Domain.Contracts.ITypedExpression<string>
    {
        [System.ComponentModel.DataAnnotations.RequiredAttribute]
        [CrossCutting.Common.DataAnnotations.ValidateObjectAttribute]
        [System.ComponentModel.DescriptionAttribute(@"String to get the upper case for")]
        public ExpressionFramework.Domain.Contracts.ITypedExpression<string> Expression
        {
            get;
        }

        [System.ComponentModel.DescriptionAttribute(@"Optional CultureInfo to use")]
        public ExpressionFramework.Domain.Contracts.ITypedExpression<System.Globalization.CultureInfo>? Culture
        {
            get;
        }

        public ToUpperCaseExpression(ExpressionFramework.Domain.Contracts.ITypedExpression<string> expression, ExpressionFramework.Domain.Contracts.ITypedExpression<System.Globalization.CultureInfo>? culture) : base()
        {
            this.Expression = expression;
            this.Culture = culture;
            System.ComponentModel.DataAnnotations.Validator.ValidateObject(this, new System.ComponentModel.DataAnnotations.ValidationContext(this, null, null), true);
        }

        public override ExpressionFramework.Domain.Builders.ExpressionBuilder ToBuilder()
        {
            return (ExpressionFramework.Domain.Builders.ExpressionBuilder)ToTypedBuilder();
        }

        public ExpressionFramework.Domain.Contracts.ITypedExpressionBuilder<string> ToTypedBuilder()
        {
            return new ExpressionFramework.Domain.Builders.Expressions.ToUpperCaseExpressionBuilder(this);
        }

        public Expression ToUntyped()
        {
            return this;
        }
    }
    [System.ComponentModel.DescriptionAttribute(@"Trims the end characters of the expression")]
    public partial record TrimEndExpression : ExpressionFramework.Domain.Expression, ExpressionFramework.Domain.Contracts.ITypedExpression<string>
    {
        [System.ComponentModel.DataAnnotations.RequiredAttribute]
        [CrossCutting.Common.DataAnnotations.ValidateObjectAttribute]
        [System.ComponentModel.DescriptionAttribute(@"String to get the trimmed value for")]
        public ExpressionFramework.Domain.Contracts.ITypedExpression<string> Expression
        {
            get;
        }

        [CrossCutting.Common.DataAnnotations.ValidateObjectAttribute]
        [System.ComponentModel.DescriptionAttribute(@"Optional trim characters, or space when empty")]
        public ExpressionFramework.Domain.Contracts.ITypedExpression<char[]>? TrimCharsExpression
        {
            get;
        }

        public TrimEndExpression(ExpressionFramework.Domain.Contracts.ITypedExpression<string> expression, ExpressionFramework.Domain.Contracts.ITypedExpression<char[]>? trimCharsExpression) : base()
        {
            this.Expression = expression;
            this.TrimCharsExpression = trimCharsExpression;
            System.ComponentModel.DataAnnotations.Validator.ValidateObject(this, new System.ComponentModel.DataAnnotations.ValidationContext(this, null, null), true);
        }

        public override ExpressionFramework.Domain.Builders.ExpressionBuilder ToBuilder()
        {
            return (ExpressionFramework.Domain.Builders.ExpressionBuilder)ToTypedBuilder();
        }

        public ExpressionFramework.Domain.Contracts.ITypedExpressionBuilder<string> ToTypedBuilder()
        {
            return new ExpressionFramework.Domain.Builders.Expressions.TrimEndExpressionBuilder(this);
        }

        public Expression ToUntyped()
        {
            return this;
        }
    }
    [System.ComponentModel.DescriptionAttribute(@"Trims the start and end characters of the expression")]
    public partial record TrimExpression : ExpressionFramework.Domain.Expression, ExpressionFramework.Domain.Contracts.ITypedExpression<string>
    {
        [System.ComponentModel.DataAnnotations.RequiredAttribute]
        [CrossCutting.Common.DataAnnotations.ValidateObjectAttribute]
        [System.ComponentModel.DescriptionAttribute(@"String to get the trimmed value for")]
        public ExpressionFramework.Domain.Contracts.ITypedExpression<string> Expression
        {
            get;
        }

        [CrossCutting.Common.DataAnnotations.ValidateObjectAttribute]
        [System.ComponentModel.DescriptionAttribute(@"Optional trim characters, or space when empty")]
        public ExpressionFramework.Domain.Contracts.ITypedExpression<char[]>? TrimCharsExpression
        {
            get;
        }

        public TrimExpression(ExpressionFramework.Domain.Contracts.ITypedExpression<string> expression, ExpressionFramework.Domain.Contracts.ITypedExpression<char[]>? trimCharsExpression) : base()
        {
            this.Expression = expression;
            this.TrimCharsExpression = trimCharsExpression;
            System.ComponentModel.DataAnnotations.Validator.ValidateObject(this, new System.ComponentModel.DataAnnotations.ValidationContext(this, null, null), true);
        }

        public override ExpressionFramework.Domain.Builders.ExpressionBuilder ToBuilder()
        {
            return (ExpressionFramework.Domain.Builders.ExpressionBuilder)ToTypedBuilder();
        }

        public ExpressionFramework.Domain.Contracts.ITypedExpressionBuilder<string> ToTypedBuilder()
        {
            return new ExpressionFramework.Domain.Builders.Expressions.TrimExpressionBuilder(this);
        }

        public Expression ToUntyped()
        {
            return this;
        }
    }
    [System.ComponentModel.DescriptionAttribute(@"Trims the start characters of the expression")]
    public partial record TrimStartExpression : ExpressionFramework.Domain.Expression, ExpressionFramework.Domain.Contracts.ITypedExpression<string>
    {
        [System.ComponentModel.DataAnnotations.RequiredAttribute]
        [CrossCutting.Common.DataAnnotations.ValidateObjectAttribute]
        [System.ComponentModel.DescriptionAttribute(@"String to get the trimmed value for")]
        public ExpressionFramework.Domain.Contracts.ITypedExpression<string> Expression
        {
            get;
        }

        [CrossCutting.Common.DataAnnotations.ValidateObjectAttribute]
        [System.ComponentModel.DescriptionAttribute(@"Optional trim characters, or space when empty")]
        public ExpressionFramework.Domain.Contracts.ITypedExpression<char[]>? TrimCharsExpression
        {
            get;
        }

        public TrimStartExpression(ExpressionFramework.Domain.Contracts.ITypedExpression<string> expression, ExpressionFramework.Domain.Contracts.ITypedExpression<char[]>? trimCharsExpression) : base()
        {
            this.Expression = expression;
            this.TrimCharsExpression = trimCharsExpression;
            System.ComponentModel.DataAnnotations.Validator.ValidateObject(this, new System.ComponentModel.DataAnnotations.ValidationContext(this, null, null), true);
        }

        public override ExpressionFramework.Domain.Builders.ExpressionBuilder ToBuilder()
        {
            return (ExpressionFramework.Domain.Builders.ExpressionBuilder)ToTypedBuilder();
        }

        public ExpressionFramework.Domain.Contracts.ITypedExpressionBuilder<string> ToTypedBuilder()
        {
            return new ExpressionFramework.Domain.Builders.Expressions.TrimStartExpressionBuilder(this);
        }

        public Expression ToUntyped()
        {
            return this;
        }
    }
    [System.ComponentModel.DescriptionAttribute(@"Returns true")]
    public partial record TrueExpression : ExpressionFramework.Domain.Expression, ExpressionFramework.Domain.Contracts.ITypedExpression<bool>
    {
        public TrueExpression() : base()
        {
            System.ComponentModel.DataAnnotations.Validator.ValidateObject(this, new System.ComponentModel.DataAnnotations.ValidationContext(this, null, null), true);
        }

        public override ExpressionFramework.Domain.Builders.ExpressionBuilder ToBuilder()
        {
            return (ExpressionFramework.Domain.Builders.ExpressionBuilder)ToTypedBuilder();
        }

        public ExpressionFramework.Domain.Contracts.ITypedExpressionBuilder<bool> ToTypedBuilder()
        {
            return new ExpressionFramework.Domain.Builders.Expressions.TrueExpressionBuilder(this);
        }

        public Expression ToUntyped()
        {
            return this;
        }
    }
    [System.ComponentModel.DescriptionAttribute(@"This expression returns the value of the source expression cast to the specified type, or the default value when this is not possible")]
    public partial record TryCastExpression<T> : ExpressionFramework.Domain.Expression, ExpressionFramework.Domain.Contracts.ITypedExpression<T>
    {
        [System.ComponentModel.DataAnnotations.RequiredAttribute]
        [CrossCutting.Common.DataAnnotations.ValidateObjectAttribute]
        [System.ComponentModel.DescriptionAttribute(@"Expression to cast")]
        public ExpressionFramework.Domain.Expression SourceExpression
        {
            get;
        }

        [CrossCutting.Common.DataAnnotations.ValidateObjectAttribute]
        [System.ComponentModel.DescriptionAttribute(@"Value to use, in case the expression could not be cast")]
        public ExpressionFramework.Domain.Contracts.ITypedExpression<T>? DefaultExpression
        {
            get;
        }

        public TryCastExpression(ExpressionFramework.Domain.Expression sourceExpression, ExpressionFramework.Domain.Contracts.ITypedExpression<T>? defaultExpression) : base()
        {
            this.SourceExpression = sourceExpression;
            this.DefaultExpression = defaultExpression;
            System.ComponentModel.DataAnnotations.Validator.ValidateObject(this, new System.ComponentModel.DataAnnotations.ValidationContext(this, null, null), true);
        }

        public override ExpressionFramework.Domain.Builders.ExpressionBuilder ToBuilder()
        {
            return (ExpressionFramework.Domain.Builders.ExpressionBuilder)ToTypedBuilder();
        }

        public ExpressionFramework.Domain.Contracts.ITypedExpressionBuilder<T> ToTypedBuilder()
        {
            return new ExpressionFramework.Domain.Builders.Expressions.TryCastExpressionBuilder<T>(this);
        }
    }
    [System.ComponentModel.DescriptionAttribute(@"Chains the result of an expression onto the next one, and so on")]
    public partial record TypedChainedExpression<T> : ExpressionFramework.Domain.Expression, ExpressionFramework.Domain.Contracts.ITypedExpression<T>
    {
        [System.ComponentModel.DataAnnotations.RequiredAttribute]
        [CrossCutting.Common.DataAnnotations.ValidateObjectAttribute]
        [System.ComponentModel.DescriptionAttribute(@"Expressions to use on chaining. The context is chained to the first expression.")]
        public System.Collections.Generic.IReadOnlyCollection<ExpressionFramework.Domain.Expression> Expressions
        {
            get;
        }

        public TypedChainedExpression(System.Collections.Generic.IEnumerable<ExpressionFramework.Domain.Expression> expressions) : base()
        {
            this.Expressions = expressions is null ? null! : new CrossCutting.Common.ReadOnlyValueCollection<ExpressionFramework.Domain.Expression>(expressions);
            System.ComponentModel.DataAnnotations.Validator.ValidateObject(this, new System.ComponentModel.DataAnnotations.ValidationContext(this, null, null), true);
        }

        public override ExpressionFramework.Domain.Builders.ExpressionBuilder ToBuilder()
        {
            return (ExpressionFramework.Domain.Builders.ExpressionBuilder)ToTypedBuilder();
        }

        public ExpressionFramework.Domain.Contracts.ITypedExpressionBuilder<T> ToTypedBuilder()
        {
            return new ExpressionFramework.Domain.Builders.Expressions.TypedChainedExpressionBuilder<T>(this);
        }
    }
    [System.ComponentModel.DescriptionAttribute(@"Returns a typed constant value")]
    public partial record TypedConstantExpression<T> : ExpressionFramework.Domain.Expression, ExpressionFramework.Domain.Contracts.ITypedExpression<T>
    {
        [System.ComponentModel.DescriptionAttribute(@"Value to use")]
        public T Value
        {
            get;
        }

        public TypedConstantExpression(T value) : base()
        {
            this.Value = value;
            System.ComponentModel.DataAnnotations.Validator.ValidateObject(this, new System.ComponentModel.DataAnnotations.ValidationContext(this, null, null), true);
        }

        public override ExpressionFramework.Domain.Builders.ExpressionBuilder ToBuilder()
        {
            return (ExpressionFramework.Domain.Builders.ExpressionBuilder)ToTypedBuilder();
        }

        public ExpressionFramework.Domain.Contracts.ITypedExpressionBuilder<T> ToTypedBuilder()
        {
            return new ExpressionFramework.Domain.Builders.Expressions.TypedConstantExpressionBuilder<T>(this);
        }
    }
    [System.ComponentModel.DescriptionAttribute(@"Returns a typed result constant value")]
    public partial record TypedConstantResultExpression<T> : ExpressionFramework.Domain.Expression, ExpressionFramework.Domain.Contracts.ITypedExpression<T>
    {
        [System.ComponentModel.DataAnnotations.RequiredAttribute]
        [System.ComponentModel.DescriptionAttribute(@"Value to use")]
        public CrossCutting.Common.Results.Result<T> Value
        {
            get;
        }

        public TypedConstantResultExpression(CrossCutting.Common.Results.Result<T> value) : base()
        {
            this.Value = value;
            System.ComponentModel.DataAnnotations.Validator.ValidateObject(this, new System.ComponentModel.DataAnnotations.ValidationContext(this, null, null), true);
        }

        public override ExpressionFramework.Domain.Builders.ExpressionBuilder ToBuilder()
        {
            return (ExpressionFramework.Domain.Builders.ExpressionBuilder)ToTypedBuilder();
        }

        public ExpressionFramework.Domain.Contracts.ITypedExpressionBuilder<T> ToTypedBuilder()
        {
            return new ExpressionFramework.Domain.Builders.Expressions.TypedConstantResultExpressionBuilder<T>(this);
        }
    }
    [System.ComponentModel.DescriptionAttribute(@"Returns the typed value of the context")]
    public partial record TypedContextExpression<T> : ExpressionFramework.Domain.Expression, ExpressionFramework.Domain.Contracts.ITypedExpression<T>
    {
        public TypedContextExpression() : base()
        {
            System.ComponentModel.DataAnnotations.Validator.ValidateObject(this, new System.ComponentModel.DataAnnotations.ValidationContext(this, null, null), true);
        }

        public override ExpressionFramework.Domain.Builders.ExpressionBuilder ToBuilder()
        {
            return (ExpressionFramework.Domain.Builders.ExpressionBuilder)ToTypedBuilder();
        }

        public ExpressionFramework.Domain.Contracts.ITypedExpressionBuilder<T> ToTypedBuilder()
        {
            return new ExpressionFramework.Domain.Builders.Expressions.TypedContextExpressionBuilder<T>(this);
        }
    }
    [System.ComponentModel.DescriptionAttribute(@"Returns a value from a typed delegate")]
    public partial record TypedDelegateExpression<T> : ExpressionFramework.Domain.Expression, ExpressionFramework.Domain.Contracts.ITypedExpression<T>
    {
        [System.ComponentModel.DataAnnotations.RequiredAttribute]
        [System.ComponentModel.DescriptionAttribute(@"Delegate to use")]
        public System.Func<object?,T> Value
        {
            get;
        }

        public TypedDelegateExpression(System.Func<object?,T> value) : base()
        {
            this.Value = value;
            System.ComponentModel.DataAnnotations.Validator.ValidateObject(this, new System.ComponentModel.DataAnnotations.ValidationContext(this, null, null), true);
        }

        public override ExpressionFramework.Domain.Builders.ExpressionBuilder ToBuilder()
        {
            return (ExpressionFramework.Domain.Builders.ExpressionBuilder)ToTypedBuilder();
        }

        public ExpressionFramework.Domain.Contracts.ITypedExpressionBuilder<T> ToTypedBuilder()
        {
            return new ExpressionFramework.Domain.Builders.Expressions.TypedDelegateExpressionBuilder<T>(this);
        }
    }
    [System.ComponentModel.DescriptionAttribute(@"Returns a typed result value from a typed delegate")]
    public partial record TypedDelegateResultExpression<T> : ExpressionFramework.Domain.Expression, ExpressionFramework.Domain.Contracts.ITypedExpression<T>
    {
        [System.ComponentModel.DataAnnotations.RequiredAttribute]
        [System.ComponentModel.DescriptionAttribute(@"Delegate to use")]
        public System.Func<object?,CrossCutting.Common.Results.Result<T>> Value
        {
            get;
        }

        public TypedDelegateResultExpression(System.Func<object?,CrossCutting.Common.Results.Result<T>> value) : base()
        {
            this.Value = value;
            System.ComponentModel.DataAnnotations.Validator.ValidateObject(this, new System.ComponentModel.DataAnnotations.ValidationContext(this, null, null), true);
        }

        public override ExpressionFramework.Domain.Builders.ExpressionBuilder ToBuilder()
        {
            return (ExpressionFramework.Domain.Builders.ExpressionBuilder)ToTypedBuilder();
        }

        public ExpressionFramework.Domain.Contracts.ITypedExpressionBuilder<T> ToTypedBuilder()
        {
            return new ExpressionFramework.Domain.Builders.Expressions.TypedDelegateResultExpressionBuilder<T>(this);
        }
    }
    [System.ComponentModel.DescriptionAttribute(@"Returns the typed value of a field (property) of the specified expression")]
    public partial record TypedFieldExpression<T> : ExpressionFramework.Domain.Expression, ExpressionFramework.Domain.Contracts.ITypedExpression<T>
    {
        [System.ComponentModel.DataAnnotations.RequiredAttribute]
        [CrossCutting.Common.DataAnnotations.ValidateObjectAttribute]
        [System.ComponentModel.DescriptionAttribute(@"Expression to get the field (property) value for")]
        public ExpressionFramework.Domain.Expression Expression
        {
            get;
        }

        [System.ComponentModel.DataAnnotations.RequiredAttribute]
        [CrossCutting.Common.DataAnnotations.ValidateObjectAttribute]
        [System.ComponentModel.DescriptionAttribute(@"Name of the field (property). Can also be nested, like Address.Street")]
        public ExpressionFramework.Domain.Contracts.ITypedExpression<string> FieldNameExpression
        {
            get;
        }

        public TypedFieldExpression(ExpressionFramework.Domain.Expression expression, ExpressionFramework.Domain.Contracts.ITypedExpression<string> fieldNameExpression) : base()
        {
            this.Expression = expression;
            this.FieldNameExpression = fieldNameExpression;
            System.ComponentModel.DataAnnotations.Validator.ValidateObject(this, new System.ComponentModel.DataAnnotations.ValidationContext(this, null, null), true);
        }

        public override ExpressionFramework.Domain.Builders.ExpressionBuilder ToBuilder()
        {
            return (ExpressionFramework.Domain.Builders.ExpressionBuilder)ToTypedBuilder();
        }

        public ExpressionFramework.Domain.Contracts.ITypedExpressionBuilder<T> ToTypedBuilder()
        {
            return new ExpressionFramework.Domain.Builders.Expressions.TypedFieldExpressionBuilder<T>(this);
        }
    }
    [System.ComponentModel.DescriptionAttribute(@"Filters an enumerable expression using a predicate")]
    public partial record WhereExpression : ExpressionFramework.Domain.Expression, ExpressionFramework.Domain.Contracts.ITypedExpression<System.Collections.Generic.IEnumerable<object?>>
    {
        [System.ComponentModel.DataAnnotations.RequiredAttribute]
        [CrossCutting.Common.DataAnnotations.ValidateObjectAttribute]
        [System.ComponentModel.DescriptionAttribute(@"Enumerable expression to use")]
        public ExpressionFramework.Domain.Contracts.ITypedExpression<System.Collections.IEnumerable> Expression
        {
            get;
        }

        [System.ComponentModel.DataAnnotations.RequiredAttribute]
        [CrossCutting.Common.DataAnnotations.ValidateObjectAttribute]
        [System.ComponentModel.DescriptionAttribute(@"Predicate to use")]
        public ExpressionFramework.Domain.Contracts.ITypedExpression<bool> PredicateExpression
        {
            get;
        }

        public WhereExpression(ExpressionFramework.Domain.Contracts.ITypedExpression<System.Collections.IEnumerable> expression, ExpressionFramework.Domain.Contracts.ITypedExpression<bool> predicateExpression) : base()
        {
            this.Expression = expression;
            this.PredicateExpression = predicateExpression;
            System.ComponentModel.DataAnnotations.Validator.ValidateObject(this, new System.ComponentModel.DataAnnotations.ValidationContext(this, null, null), true);
        }

        public override ExpressionFramework.Domain.Builders.ExpressionBuilder ToBuilder()
        {
            return (ExpressionFramework.Domain.Builders.ExpressionBuilder)ToTypedBuilder();
        }

        public ExpressionFramework.Domain.Contracts.ITypedExpressionBuilder<System.Collections.Generic.IEnumerable<object?>> ToTypedBuilder()
        {
            return new ExpressionFramework.Domain.Builders.Expressions.WhereExpressionBuilder(this);
        }

        public Expression ToUntyped()
        {
            return this;
        }
    }
    [System.ComponentModel.DescriptionAttribute(@"Returns the year from the specified DateTime expression")]
    public partial record YearExpression : ExpressionFramework.Domain.Expression, ExpressionFramework.Domain.Contracts.ITypedExpression<int>
    {
        [System.ComponentModel.DataAnnotations.RequiredAttribute]
        [CrossCutting.Common.DataAnnotations.ValidateObjectAttribute]
        [System.ComponentModel.DescriptionAttribute(@"DateTime source expression")]
        public ExpressionFramework.Domain.Contracts.ITypedExpression<System.DateTime> Expression
        {
            get;
        }

        public YearExpression(ExpressionFramework.Domain.Contracts.ITypedExpression<System.DateTime> expression) : base()
        {
            this.Expression = expression;
            System.ComponentModel.DataAnnotations.Validator.ValidateObject(this, new System.ComponentModel.DataAnnotations.ValidationContext(this, null, null), true);
        }

        public override ExpressionFramework.Domain.Builders.ExpressionBuilder ToBuilder()
        {
            return (ExpressionFramework.Domain.Builders.ExpressionBuilder)ToTypedBuilder();
        }

        public ExpressionFramework.Domain.Contracts.ITypedExpressionBuilder<int> ToTypedBuilder()
        {
            return new ExpressionFramework.Domain.Builders.Expressions.YearExpressionBuilder(this);
        }

        public Expression ToUntyped()
        {
            return this;
        }
    }
}
#nullable disable
