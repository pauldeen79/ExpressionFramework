// ------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version: 9.0.0
//  
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
// ------------------------------------------------------------------------------
#nullable enable
namespace ExpressionFramework.Parser.EvaluatableResultParsers
{
    [FunctionName(@"ComposableEvaluatable")]
    [FunctionArgument(@"LeftExpression", typeof(object))]
    [FunctionArgument(@"Operator", typeof(ExpressionFramework.Domain.Operator))]
    [FunctionArgument(@"RightExpression", typeof(object))]
    [FunctionArgument(@"Combination", typeof(System.Nullable<ExpressionFramework.Domain.Domains.Combination>))]
    [FunctionArgument(@"StartGroup", typeof(System.Boolean))]
    [FunctionArgument(@"EndGroup", typeof(System.Boolean))]
    public class ComposableEvaluatableParser : EvaluatableParserBase
    {
        protected override CrossCutting.Common.Results.Result<ExpressionFramework.Domain.Evaluatable> DoParse(CrossCutting.Utilities.Parsers.FunctionCallContext context)
        {
            var operatorResult = context.GetArgumentExpressionResult<ExpressionFramework.Domain.Operator>(1, @"Operator");
            var combinationResult = context.GetArgumentExpressionResult<ExpressionFramework.Domain.Domains.Combination>(3, @"Combination", default);
            var startGroupResult = context.GetArgumentExpressionResult<System.Boolean>(4, @"StartGroup");
            var endGroupResult = context.GetArgumentExpressionResult<System.Boolean>(5, @"EndGroup");
            var error = new Result[]
            {
                operatorResult,
                combinationResult,
                startGroupResult,
                endGroupResult,
            }.FirstOrDefault(x => !x.IsSuccessful());
            if (error is not null)
            {
                return Result.FromExistingResult<ExpressionFramework.Domain.Evaluatable>(error);
            }
            #pragma warning disable CS8620 // Argument cannot be used for parameter due to differences in the nullability of reference types.
            return Result.Success<ExpressionFramework.Domain.Evaluatable>(new ExpressionFramework.Domain.Evaluatables.ComposableEvaluatable(
                new TypedConstantResultExpression<System.Object>(context.GetArgumentValueResult(0, @"LeftExpression")),
                operatorResult.Value!,
                new TypedConstantResultExpression<System.Object>(context.GetArgumentValueResult(2, @"RightExpression")),
                combinationResult.Value,
                startGroupResult.Value!,
                endGroupResult.Value!));
            #pragma warning restore CS8620 // Argument cannot be used for parameter due to differences in the nullability of reference types.
        }
    }
    [FunctionName(@"ComposedEvaluatable")]
    [FunctionArgument(@"Conditions", typeof(System.Collections.Generic.IReadOnlyCollection<ExpressionFramework.Domain.Evaluatables.ComposableEvaluatable>))]
    public class ComposedEvaluatableParser : EvaluatableParserBase
    {
        protected override CrossCutting.Common.Results.Result<ExpressionFramework.Domain.Evaluatable> DoParse(CrossCutting.Utilities.Parsers.FunctionCallContext context)
        {
            var conditionsResult = context.GetArgumentExpressionResult<System.Collections.Generic.IEnumerable<ExpressionFramework.Domain.Evaluatables.ComposableEvaluatable>>(0, @"Conditions");
            var error = new Result[]
            {
                conditionsResult,
            }.FirstOrDefault(x => !x.IsSuccessful());
            if (error is not null)
            {
                return Result.FromExistingResult<ExpressionFramework.Domain.Evaluatable>(error);
            }
            #pragma warning disable CS8620 // Argument cannot be used for parameter due to differences in the nullability of reference types.
            return Result.Success<ExpressionFramework.Domain.Evaluatable>(new ExpressionFramework.Domain.Evaluatables.ComposedEvaluatable(
                conditionsResult.Value!));
            #pragma warning restore CS8620 // Argument cannot be used for parameter due to differences in the nullability of reference types.
        }
    }
    [FunctionName(@"ConstantEvaluatable")]
    [FunctionArgument(@"Value", typeof(System.Boolean))]
    public class ConstantEvaluatableParser : EvaluatableParserBase
    {
        protected override CrossCutting.Common.Results.Result<ExpressionFramework.Domain.Evaluatable> DoParse(CrossCutting.Utilities.Parsers.FunctionCallContext context)
        {
            var valueResult = context.GetArgumentExpressionResult<System.Boolean>(0, @"Value");
            var error = new Result[]
            {
                valueResult,
            }.FirstOrDefault(x => !x.IsSuccessful());
            if (error is not null)
            {
                return Result.FromExistingResult<ExpressionFramework.Domain.Evaluatable>(error);
            }
            #pragma warning disable CS8620 // Argument cannot be used for parameter due to differences in the nullability of reference types.
            return Result.Success<ExpressionFramework.Domain.Evaluatable>(new ExpressionFramework.Domain.Evaluatables.ConstantEvaluatable(
                valueResult.Value!));
            #pragma warning restore CS8620 // Argument cannot be used for parameter due to differences in the nullability of reference types.
        }
    }
    [FunctionName(@"DelegateEvaluatable")]
    [FunctionArgument(@"Value", typeof(System.Func<System.Boolean>))]
    public class DelegateEvaluatableParser : EvaluatableParserBase
    {
        protected override CrossCutting.Common.Results.Result<ExpressionFramework.Domain.Evaluatable> DoParse(CrossCutting.Utilities.Parsers.FunctionCallContext context)
        {
            var valueResult = context.GetArgumentExpressionResult<System.Func<System.Boolean>>(0, @"Value");
            var error = new Result[]
            {
                valueResult,
            }.FirstOrDefault(x => !x.IsSuccessful());
            if (error is not null)
            {
                return Result.FromExistingResult<ExpressionFramework.Domain.Evaluatable>(error);
            }
            #pragma warning disable CS8620 // Argument cannot be used for parameter due to differences in the nullability of reference types.
            return Result.Success<ExpressionFramework.Domain.Evaluatable>(new ExpressionFramework.Domain.Evaluatables.DelegateEvaluatable(
                valueResult.Value!));
            #pragma warning restore CS8620 // Argument cannot be used for parameter due to differences in the nullability of reference types.
        }
    }
    [FunctionName(@"SingleEvaluatable")]
    [FunctionArgument(@"LeftExpression", typeof(object))]
    [FunctionArgument(@"Operator", typeof(ExpressionFramework.Domain.Operator))]
    [FunctionArgument(@"RightExpression", typeof(object))]
    public class SingleEvaluatableParser : EvaluatableParserBase
    {
        protected override CrossCutting.Common.Results.Result<ExpressionFramework.Domain.Evaluatable> DoParse(CrossCutting.Utilities.Parsers.FunctionCallContext context)
        {
            var operatorResult = context.GetArgumentExpressionResult<ExpressionFramework.Domain.Operator>(1, @"Operator");
            var error = new Result[]
            {
                operatorResult,
            }.FirstOrDefault(x => !x.IsSuccessful());
            if (error is not null)
            {
                return Result.FromExistingResult<ExpressionFramework.Domain.Evaluatable>(error);
            }
            #pragma warning disable CS8620 // Argument cannot be used for parameter due to differences in the nullability of reference types.
            return Result.Success<ExpressionFramework.Domain.Evaluatable>(new ExpressionFramework.Domain.Evaluatables.SingleEvaluatable(
                new TypedConstantResultExpression<System.Object>(context.GetArgumentValueResult(0, @"LeftExpression")),
                operatorResult.Value!,
                new TypedConstantResultExpression<System.Object>(context.GetArgumentValueResult(2, @"RightExpression"))));
            #pragma warning restore CS8620 // Argument cannot be used for parameter due to differences in the nullability of reference types.
        }
    }
}
#nullable disable
