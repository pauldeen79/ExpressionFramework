// ------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version: 8.0.10
//  
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
// ------------------------------------------------------------------------------
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

#nullable enable
namespace ExpressionFramework.Parser.ExpressionResultParsers
{
    public class AggregateExpressionParser : ExpressionParserBase
    {
        public AggregateExpressionParser() : base(@"Aggregate")
        {
        }

        protected override CrossCutting.Common.Results.Result<ExpressionFramework.Domain.Expression> DoParse(CrossCutting.Utilities.Parsers.FunctionParseResult functionParseResult, CrossCutting.Utilities.Parsers.Contracts.IFunctionParseResultEvaluator evaluator, CrossCutting.Utilities.Parsers.Contracts.IExpressionParser parser)
        {
            var aggregatorResult = functionParseResult.GetArgumentExpressionResult<ExpressionFramework.Domain.Aggregator>(1, @"Aggregator", functionParseResult.Context, evaluator, parser);
            var error = new Result[]
            {
                aggregatorResult,
            }.FirstOrDefault(x => !x.IsSuccessful());
            if (error != null)
            {
                return Result.FromExistingResult<ExpressionFramework.Domain.Expression>(error);
            }
            #pragma warning disable CS8620 // Argument cannot be used for parameter due to differences in the nullability of reference types.
            return Result.Success<ExpressionFramework.Domain.Expression>(new ExpressionFramework.Domain.Expressions.AggregateExpression(
    functionParseResult.GetExpressionsArgumentValueResult(0, @"Expressions", evaluator, parser),
    aggregatorResult.Value!,
    functionParseResult.GetArgumentValueExpression<System.IFormatProvider>(2, @"FormatProviderExpression", evaluator, parser, default)));
            #pragma warning restore CS8620 // Argument cannot be used for parameter due to differences in the nullability of reference types.
        }
    }
    public class AllExpressionParser : ExpressionParserBase
    {
        public AllExpressionParser() : base(@"All")
        {
        }

        protected override CrossCutting.Common.Results.Result<ExpressionFramework.Domain.Expression> DoParse(CrossCutting.Utilities.Parsers.FunctionParseResult functionParseResult, CrossCutting.Utilities.Parsers.Contracts.IFunctionParseResultEvaluator evaluator, CrossCutting.Utilities.Parsers.Contracts.IExpressionParser parser)
        {
            #pragma warning disable CS8620 // Argument cannot be used for parameter due to differences in the nullability of reference types.
            return Result.Success<ExpressionFramework.Domain.Expression>(new ExpressionFramework.Domain.Expressions.AllExpression(
    functionParseResult.GetTypedExpressionsArgumentValueExpression(0, @"Expression", evaluator, parser),
    functionParseResult.GetArgumentBooleanValueExpression(1, @"PredicateExpression", evaluator, parser)));
            #pragma warning restore CS8620 // Argument cannot be used for parameter due to differences in the nullability of reference types.
        }
    }
    public class AndExpressionParser : ExpressionParserBase
    {
        public AndExpressionParser() : base(@"And")
        {
        }

        protected override CrossCutting.Common.Results.Result<ExpressionFramework.Domain.Expression> DoParse(CrossCutting.Utilities.Parsers.FunctionParseResult functionParseResult, CrossCutting.Utilities.Parsers.Contracts.IFunctionParseResultEvaluator evaluator, CrossCutting.Utilities.Parsers.Contracts.IExpressionParser parser)
        {
            #pragma warning disable CS8620 // Argument cannot be used for parameter due to differences in the nullability of reference types.
            return Result.Success<ExpressionFramework.Domain.Expression>(new ExpressionFramework.Domain.Expressions.AndExpression(
    functionParseResult.GetArgumentBooleanValueExpression(0, @"FirstExpression", evaluator, parser),
    functionParseResult.GetArgumentBooleanValueExpression(1, @"SecondExpression", evaluator, parser)));
            #pragma warning restore CS8620 // Argument cannot be used for parameter due to differences in the nullability of reference types.
        }
    }
    public class AnyExpressionParser : ExpressionParserBase
    {
        public AnyExpressionParser() : base(@"Any")
        {
        }

        protected override CrossCutting.Common.Results.Result<ExpressionFramework.Domain.Expression> DoParse(CrossCutting.Utilities.Parsers.FunctionParseResult functionParseResult, CrossCutting.Utilities.Parsers.Contracts.IFunctionParseResultEvaluator evaluator, CrossCutting.Utilities.Parsers.Contracts.IExpressionParser parser)
        {
            #pragma warning disable CS8620 // Argument cannot be used for parameter due to differences in the nullability of reference types.
            return Result.Success<ExpressionFramework.Domain.Expression>(new ExpressionFramework.Domain.Expressions.AnyExpression(
    functionParseResult.GetTypedExpressionsArgumentValueExpression(0, @"Expression", evaluator, parser),
    functionParseResult.GetArgumentBooleanValueExpression(1, @"PredicateExpression", evaluator, parser, default)));
            #pragma warning restore CS8620 // Argument cannot be used for parameter due to differences in the nullability of reference types.
        }
    }
    public class CastExpressionParser : ExpressionParserBase
    {
        public CastExpressionParser() : base(@"Cast")
        {
        }

        protected override CrossCutting.Common.Results.Result<ExpressionFramework.Domain.Expression> DoParse(CrossCutting.Utilities.Parsers.FunctionParseResult functionParseResult, CrossCutting.Utilities.Parsers.Contracts.IFunctionParseResultEvaluator evaluator, CrossCutting.Utilities.Parsers.Contracts.IExpressionParser parser)
        {
            return ParseTypedExpression(typeof(CastExpression<>), 0, @"SourceExpression", functionParseResult, evaluator, parser);
        }

        protected override bool IsNameValid(string functionName)
        {
            return base.IsNameValid(functionName.WithoutGenerics());
        }
    }
    public class ChainedExpressionParser : ExpressionParserBase
    {
        public ChainedExpressionParser() : base(@"Chained")
        {
        }

        protected override CrossCutting.Common.Results.Result<ExpressionFramework.Domain.Expression> DoParse(CrossCutting.Utilities.Parsers.FunctionParseResult functionParseResult, CrossCutting.Utilities.Parsers.Contracts.IFunctionParseResultEvaluator evaluator, CrossCutting.Utilities.Parsers.Contracts.IExpressionParser parser)
        {
            #pragma warning disable CS8620 // Argument cannot be used for parameter due to differences in the nullability of reference types.
            return Result.Success<ExpressionFramework.Domain.Expression>(new ExpressionFramework.Domain.Expressions.ChainedExpression(
    functionParseResult.GetExpressionsArgumentValueResult(0, @"Expressions", evaluator, parser)));
            #pragma warning restore CS8620 // Argument cannot be used for parameter due to differences in the nullability of reference types.
        }
    }
    public class CompoundExpressionParser : ExpressionParserBase
    {
        public CompoundExpressionParser() : base(@"Compound")
        {
        }

        protected override CrossCutting.Common.Results.Result<ExpressionFramework.Domain.Expression> DoParse(CrossCutting.Utilities.Parsers.FunctionParseResult functionParseResult, CrossCutting.Utilities.Parsers.Contracts.IFunctionParseResultEvaluator evaluator, CrossCutting.Utilities.Parsers.Contracts.IExpressionParser parser)
        {
            var aggregatorResult = functionParseResult.GetArgumentExpressionResult<ExpressionFramework.Domain.Aggregator>(2, @"Aggregator", functionParseResult.Context, evaluator, parser);
            var error = new Result[]
            {
                aggregatorResult,
            }.FirstOrDefault(x => !x.IsSuccessful());
            if (error != null)
            {
                return Result.FromExistingResult<ExpressionFramework.Domain.Expression>(error);
            }
            #pragma warning disable CS8620 // Argument cannot be used for parameter due to differences in the nullability of reference types.
            return Result.Success<ExpressionFramework.Domain.Expression>(new ExpressionFramework.Domain.Expressions.CompoundExpression(
    new TypedConstantResultExpression<System.Object>(functionParseResult.GetArgumentValueResult(0, @"FirstExpression", functionParseResult.Context, evaluator, parser)),
    new TypedConstantResultExpression<System.Object>(functionParseResult.GetArgumentValueResult(1, @"SecondExpression", functionParseResult.Context, evaluator, parser)),
    aggregatorResult.Value!,
    functionParseResult.GetArgumentValueExpression<System.IFormatProvider>(3, @"FormatProviderExpression", evaluator, parser, default)));
            #pragma warning restore CS8620 // Argument cannot be used for parameter due to differences in the nullability of reference types.
        }
    }
    public class ConstantExpressionParser : ExpressionParserBase
    {
        public ConstantExpressionParser() : base(@"Constant")
        {
        }

        protected override CrossCutting.Common.Results.Result<ExpressionFramework.Domain.Expression> DoParse(CrossCutting.Utilities.Parsers.FunctionParseResult functionParseResult, CrossCutting.Utilities.Parsers.Contracts.IFunctionParseResultEvaluator evaluator, CrossCutting.Utilities.Parsers.Contracts.IExpressionParser parser)
        {
            var valueResult = functionParseResult.GetArgumentValueResult(0, @"Value", functionParseResult.Context, evaluator, parser, default);
            var error = new Result[]
            {
                valueResult,
            }.FirstOrDefault(x => !x.IsSuccessful());
            if (error != null)
            {
                return Result.FromExistingResult<ExpressionFramework.Domain.Expression>(error);
            }
            #pragma warning disable CS8620 // Argument cannot be used for parameter due to differences in the nullability of reference types.
            return Result.Success<ExpressionFramework.Domain.Expression>(new ExpressionFramework.Domain.Expressions.ConstantExpression(
    valueResult.Value));
            #pragma warning restore CS8620 // Argument cannot be used for parameter due to differences in the nullability of reference types.
        }
    }
    public class ConstantResultExpressionParser : ExpressionParserBase
    {
        public ConstantResultExpressionParser() : base(@"ConstantResult")
        {
        }

        protected override CrossCutting.Common.Results.Result<ExpressionFramework.Domain.Expression> DoParse(CrossCutting.Utilities.Parsers.FunctionParseResult functionParseResult, CrossCutting.Utilities.Parsers.Contracts.IFunctionParseResultEvaluator evaluator, CrossCutting.Utilities.Parsers.Contracts.IExpressionParser parser)
        {
            var valueResult = functionParseResult.GetArgumentExpressionResult<CrossCutting.Common.Results.Result>(0, @"Value", functionParseResult.Context, evaluator, parser);
            var error = new Result[]
            {
                valueResult,
            }.FirstOrDefault(x => !x.IsSuccessful());
            if (error != null)
            {
                return Result.FromExistingResult<ExpressionFramework.Domain.Expression>(error);
            }
            #pragma warning disable CS8620 // Argument cannot be used for parameter due to differences in the nullability of reference types.
            return Result.Success<ExpressionFramework.Domain.Expression>(new ExpressionFramework.Domain.Expressions.ConstantResultExpression(
    valueResult.Value!));
            #pragma warning restore CS8620 // Argument cannot be used for parameter due to differences in the nullability of reference types.
        }
    }
    public class ContextExpressionParser : ExpressionParserBase
    {
        public ContextExpressionParser() : base(@"Context")
        {
        }

        protected override CrossCutting.Common.Results.Result<ExpressionFramework.Domain.Expression> DoParse(CrossCutting.Utilities.Parsers.FunctionParseResult functionParseResult, CrossCutting.Utilities.Parsers.Contracts.IFunctionParseResultEvaluator evaluator, CrossCutting.Utilities.Parsers.Contracts.IExpressionParser parser)
        {
            #pragma warning disable CS8620 // Argument cannot be used for parameter due to differences in the nullability of reference types.
            return Result.Success<ExpressionFramework.Domain.Expression>(new ExpressionFramework.Domain.Expressions.ContextExpression(
    ));
            #pragma warning restore CS8620 // Argument cannot be used for parameter due to differences in the nullability of reference types.
        }
    }
    public class CountExpressionParser : ExpressionParserBase
    {
        public CountExpressionParser() : base(@"Count")
        {
        }

        protected override CrossCutting.Common.Results.Result<ExpressionFramework.Domain.Expression> DoParse(CrossCutting.Utilities.Parsers.FunctionParseResult functionParseResult, CrossCutting.Utilities.Parsers.Contracts.IFunctionParseResultEvaluator evaluator, CrossCutting.Utilities.Parsers.Contracts.IExpressionParser parser)
        {
            #pragma warning disable CS8620 // Argument cannot be used for parameter due to differences in the nullability of reference types.
            return Result.Success<ExpressionFramework.Domain.Expression>(new ExpressionFramework.Domain.Expressions.CountExpression(
    functionParseResult.GetTypedExpressionsArgumentValueExpression(0, @"Expression", evaluator, parser),
    functionParseResult.GetArgumentBooleanValueExpression(1, @"PredicateExpression", evaluator, parser, default)));
            #pragma warning restore CS8620 // Argument cannot be used for parameter due to differences in the nullability of reference types.
        }
    }
    public class DayExpressionParser : ExpressionParserBase
    {
        public DayExpressionParser() : base(@"Day")
        {
        }

        protected override CrossCutting.Common.Results.Result<ExpressionFramework.Domain.Expression> DoParse(CrossCutting.Utilities.Parsers.FunctionParseResult functionParseResult, CrossCutting.Utilities.Parsers.Contracts.IFunctionParseResultEvaluator evaluator, CrossCutting.Utilities.Parsers.Contracts.IExpressionParser parser)
        {
            #pragma warning disable CS8620 // Argument cannot be used for parameter due to differences in the nullability of reference types.
            return Result.Success<ExpressionFramework.Domain.Expression>(new ExpressionFramework.Domain.Expressions.DayExpression(
    functionParseResult.GetArgumentDateTimeValueExpression(0, @"Expression", evaluator, parser)));
            #pragma warning restore CS8620 // Argument cannot be used for parameter due to differences in the nullability of reference types.
        }
    }
    public class DefaultExpressionParser : ExpressionParserBase
    {
        public DefaultExpressionParser() : base(@"Default")
        {
        }

        protected override CrossCutting.Common.Results.Result<ExpressionFramework.Domain.Expression> DoParse(CrossCutting.Utilities.Parsers.FunctionParseResult functionParseResult, CrossCutting.Utilities.Parsers.Contracts.IFunctionParseResultEvaluator evaluator, CrossCutting.Utilities.Parsers.Contracts.IExpressionParser parser)
        {
            var typeResult = functionParseResult.FunctionName.GetGenericTypeResult();
            if (!typeResult.IsSuccessful())
            {
                return Result.FromExistingResult<ExpressionFramework.Domain.Expression>(typeResult);
            }
            #pragma warning disable CS8620 // Argument cannot be used for parameter due to differences in the nullability of reference types.
            return Result.Success<ExpressionFramework.Domain.Expression>((ExpressionFramework.Domain.Expression)System.Activator.CreateInstance(typeof(ExpressionFramework.Domain.Expressions.DefaultExpression<>).MakeGenericType(typeResult.Value!)));
            #pragma warning restore CS8620 // Argument cannot be used for parameter due to differences in the nullability of reference types.
        }

        protected override bool IsNameValid(string functionName)
        {
            return base.IsNameValid(functionName.WithoutGenerics());
        }
    }
    public class DelegateExpressionParser : ExpressionParserBase
    {
        public DelegateExpressionParser() : base(@"Delegate")
        {
        }

        protected override CrossCutting.Common.Results.Result<ExpressionFramework.Domain.Expression> DoParse(CrossCutting.Utilities.Parsers.FunctionParseResult functionParseResult, CrossCutting.Utilities.Parsers.Contracts.IFunctionParseResultEvaluator evaluator, CrossCutting.Utilities.Parsers.Contracts.IExpressionParser parser)
        {
            var valueResult = functionParseResult.GetArgumentExpressionResult<System.Func<System.Object?,System.Object?>>(0, @"Value", functionParseResult.Context, evaluator, parser);
            var error = new Result[]
            {
                valueResult,
            }.FirstOrDefault(x => !x.IsSuccessful());
            if (error != null)
            {
                return Result.FromExistingResult<ExpressionFramework.Domain.Expression>(error);
            }
            #pragma warning disable CS8620 // Argument cannot be used for parameter due to differences in the nullability of reference types.
            return Result.Success<ExpressionFramework.Domain.Expression>(new ExpressionFramework.Domain.Expressions.DelegateExpression(
    valueResult.Value!));
            #pragma warning restore CS8620 // Argument cannot be used for parameter due to differences in the nullability of reference types.
        }
    }
    public class DelegateResultExpressionParser : ExpressionParserBase
    {
        public DelegateResultExpressionParser() : base(@"DelegateResult")
        {
        }

        protected override CrossCutting.Common.Results.Result<ExpressionFramework.Domain.Expression> DoParse(CrossCutting.Utilities.Parsers.FunctionParseResult functionParseResult, CrossCutting.Utilities.Parsers.Contracts.IFunctionParseResultEvaluator evaluator, CrossCutting.Utilities.Parsers.Contracts.IExpressionParser parser)
        {
            var resultResult = functionParseResult.GetArgumentExpressionResult<System.Func<System.Object?,CrossCutting.Common.Results.Result<System.Object?>>>(0, @"Result", functionParseResult.Context, evaluator, parser);
            var error = new Result[]
            {
                resultResult,
            }.FirstOrDefault(x => !x.IsSuccessful());
            if (error != null)
            {
                return Result.FromExistingResult<ExpressionFramework.Domain.Expression>(error);
            }
            #pragma warning disable CS8620 // Argument cannot be used for parameter due to differences in the nullability of reference types.
            return Result.Success<ExpressionFramework.Domain.Expression>(new ExpressionFramework.Domain.Expressions.DelegateResultExpression(
    resultResult.Value!));
            #pragma warning restore CS8620 // Argument cannot be used for parameter due to differences in the nullability of reference types.
        }
    }
    public class ElementAtExpressionParser : ExpressionParserBase
    {
        public ElementAtExpressionParser() : base(@"ElementAt")
        {
        }

        protected override CrossCutting.Common.Results.Result<ExpressionFramework.Domain.Expression> DoParse(CrossCutting.Utilities.Parsers.FunctionParseResult functionParseResult, CrossCutting.Utilities.Parsers.Contracts.IFunctionParseResultEvaluator evaluator, CrossCutting.Utilities.Parsers.Contracts.IExpressionParser parser)
        {
            #pragma warning disable CS8620 // Argument cannot be used for parameter due to differences in the nullability of reference types.
            return Result.Success<ExpressionFramework.Domain.Expression>(new ExpressionFramework.Domain.Expressions.ElementAtExpression(
    functionParseResult.GetTypedExpressionsArgumentValueExpression(0, @"Expression", evaluator, parser),
    functionParseResult.GetArgumentInt32ValueExpression(1, @"IndexExpression", evaluator, parser)));
            #pragma warning restore CS8620 // Argument cannot be used for parameter due to differences in the nullability of reference types.
        }
    }
    public class ElementAtOrDefaultExpressionParser : ExpressionParserBase
    {
        public ElementAtOrDefaultExpressionParser() : base(@"ElementAtOrDefault")
        {
        }

        protected override CrossCutting.Common.Results.Result<ExpressionFramework.Domain.Expression> DoParse(CrossCutting.Utilities.Parsers.FunctionParseResult functionParseResult, CrossCutting.Utilities.Parsers.Contracts.IFunctionParseResultEvaluator evaluator, CrossCutting.Utilities.Parsers.Contracts.IExpressionParser parser)
        {
            #pragma warning disable CS8620 // Argument cannot be used for parameter due to differences in the nullability of reference types.
            return Result.Success<ExpressionFramework.Domain.Expression>(new ExpressionFramework.Domain.Expressions.ElementAtOrDefaultExpression(
    functionParseResult.GetTypedExpressionsArgumentValueExpression(0, @"Expression", evaluator, parser),
    functionParseResult.GetArgumentInt32ValueExpression(1, @"IndexExpression", evaluator, parser),
    new TypedConstantResultExpression<System.Object?>(functionParseResult.GetArgumentValueResult(2, @"DefaultExpression", functionParseResult.Context, evaluator, parser, default))));
            #pragma warning restore CS8620 // Argument cannot be used for parameter due to differences in the nullability of reference types.
        }
    }
    public class EmptyExpressionParser : ExpressionParserBase
    {
        public EmptyExpressionParser() : base(@"Empty")
        {
        }

        protected override CrossCutting.Common.Results.Result<ExpressionFramework.Domain.Expression> DoParse(CrossCutting.Utilities.Parsers.FunctionParseResult functionParseResult, CrossCutting.Utilities.Parsers.Contracts.IFunctionParseResultEvaluator evaluator, CrossCutting.Utilities.Parsers.Contracts.IExpressionParser parser)
        {
            #pragma warning disable CS8620 // Argument cannot be used for parameter due to differences in the nullability of reference types.
            return Result.Success<ExpressionFramework.Domain.Expression>(new ExpressionFramework.Domain.Expressions.EmptyExpression(
    ));
            #pragma warning restore CS8620 // Argument cannot be used for parameter due to differences in the nullability of reference types.
        }
    }
    public class EqualsExpressionParser : ExpressionParserBase
    {
        public EqualsExpressionParser() : base(@"Equals")
        {
        }

        protected override CrossCutting.Common.Results.Result<ExpressionFramework.Domain.Expression> DoParse(CrossCutting.Utilities.Parsers.FunctionParseResult functionParseResult, CrossCutting.Utilities.Parsers.Contracts.IFunctionParseResultEvaluator evaluator, CrossCutting.Utilities.Parsers.Contracts.IExpressionParser parser)
        {
            #pragma warning disable CS8620 // Argument cannot be used for parameter due to differences in the nullability of reference types.
            return Result.Success<ExpressionFramework.Domain.Expression>(new ExpressionFramework.Domain.Expressions.EqualsExpression(
    new TypedConstantResultExpression<System.Object>(functionParseResult.GetArgumentValueResult(0, @"FirstExpression", functionParseResult.Context, evaluator, parser)),
    new TypedConstantResultExpression<System.Object>(functionParseResult.GetArgumentValueResult(1, @"SecondExpression", functionParseResult.Context, evaluator, parser))));
            #pragma warning restore CS8620 // Argument cannot be used for parameter due to differences in the nullability of reference types.
        }
    }
    public class ErrorExpressionParser : ExpressionParserBase
    {
        public ErrorExpressionParser() : base(@"Error")
        {
        }

        protected override CrossCutting.Common.Results.Result<ExpressionFramework.Domain.Expression> DoParse(CrossCutting.Utilities.Parsers.FunctionParseResult functionParseResult, CrossCutting.Utilities.Parsers.Contracts.IFunctionParseResultEvaluator evaluator, CrossCutting.Utilities.Parsers.Contracts.IExpressionParser parser)
        {
            #pragma warning disable CS8620 // Argument cannot be used for parameter due to differences in the nullability of reference types.
            return Result.Success<ExpressionFramework.Domain.Expression>(new ExpressionFramework.Domain.Expressions.ErrorExpression(
    functionParseResult.GetArgumentStringValueExpression(0, @"ErrorMessageExpression", evaluator, parser)));
            #pragma warning restore CS8620 // Argument cannot be used for parameter due to differences in the nullability of reference types.
        }
    }
    public class EvaluatableExpressionParser : ExpressionParserBase
    {
        public EvaluatableExpressionParser() : base(@"Evaluatable")
        {
        }

        protected override CrossCutting.Common.Results.Result<ExpressionFramework.Domain.Expression> DoParse(CrossCutting.Utilities.Parsers.FunctionParseResult functionParseResult, CrossCutting.Utilities.Parsers.Contracts.IFunctionParseResultEvaluator evaluator, CrossCutting.Utilities.Parsers.Contracts.IExpressionParser parser)
        {
            var conditionResult = functionParseResult.GetArgumentExpressionResult<ExpressionFramework.Domain.Evaluatable>(0, @"Condition", functionParseResult.Context, evaluator, parser);
            var error = new Result[]
            {
                conditionResult,
            }.FirstOrDefault(x => !x.IsSuccessful());
            if (error != null)
            {
                return Result.FromExistingResult<ExpressionFramework.Domain.Expression>(error);
            }
            #pragma warning disable CS8620 // Argument cannot be used for parameter due to differences in the nullability of reference types.
            return Result.Success<ExpressionFramework.Domain.Expression>(new ExpressionFramework.Domain.Expressions.EvaluatableExpression(
    conditionResult.Value!,
    new TypedConstantResultExpression<System.Object>(functionParseResult.GetArgumentValueResult(1, @"Expression", functionParseResult.Context, evaluator, parser))));
            #pragma warning restore CS8620 // Argument cannot be used for parameter due to differences in the nullability of reference types.
        }
    }
    public class FalseExpressionParser : ExpressionParserBase
    {
        public FalseExpressionParser() : base(@"False")
        {
        }

        protected override CrossCutting.Common.Results.Result<ExpressionFramework.Domain.Expression> DoParse(CrossCutting.Utilities.Parsers.FunctionParseResult functionParseResult, CrossCutting.Utilities.Parsers.Contracts.IFunctionParseResultEvaluator evaluator, CrossCutting.Utilities.Parsers.Contracts.IExpressionParser parser)
        {
            #pragma warning disable CS8620 // Argument cannot be used for parameter due to differences in the nullability of reference types.
            return Result.Success<ExpressionFramework.Domain.Expression>(new ExpressionFramework.Domain.Expressions.FalseExpression(
    ));
            #pragma warning restore CS8620 // Argument cannot be used for parameter due to differences in the nullability of reference types.
        }
    }
    public class FieldExpressionParser : ExpressionParserBase
    {
        public FieldExpressionParser() : base(@"Field")
        {
        }

        protected override CrossCutting.Common.Results.Result<ExpressionFramework.Domain.Expression> DoParse(CrossCutting.Utilities.Parsers.FunctionParseResult functionParseResult, CrossCutting.Utilities.Parsers.Contracts.IFunctionParseResultEvaluator evaluator, CrossCutting.Utilities.Parsers.Contracts.IExpressionParser parser)
        {
            #pragma warning disable CS8620 // Argument cannot be used for parameter due to differences in the nullability of reference types.
            return Result.Success<ExpressionFramework.Domain.Expression>(new ExpressionFramework.Domain.Expressions.FieldExpression(
    new TypedConstantResultExpression<System.Object>(functionParseResult.GetArgumentValueResult(0, @"Expression", functionParseResult.Context, evaluator, parser)),
    functionParseResult.GetArgumentStringValueExpression(1, @"FieldNameExpression", evaluator, parser)));
            #pragma warning restore CS8620 // Argument cannot be used for parameter due to differences in the nullability of reference types.
        }
    }
    public class FirstExpressionParser : ExpressionParserBase
    {
        public FirstExpressionParser() : base(@"First")
        {
        }

        protected override CrossCutting.Common.Results.Result<ExpressionFramework.Domain.Expression> DoParse(CrossCutting.Utilities.Parsers.FunctionParseResult functionParseResult, CrossCutting.Utilities.Parsers.Contracts.IFunctionParseResultEvaluator evaluator, CrossCutting.Utilities.Parsers.Contracts.IExpressionParser parser)
        {
            #pragma warning disable CS8620 // Argument cannot be used for parameter due to differences in the nullability of reference types.
            return Result.Success<ExpressionFramework.Domain.Expression>(new ExpressionFramework.Domain.Expressions.FirstExpression(
    functionParseResult.GetTypedExpressionsArgumentValueExpression(0, @"Expression", evaluator, parser),
    functionParseResult.GetArgumentBooleanValueExpression(1, @"PredicateExpression", evaluator, parser, default)));
            #pragma warning restore CS8620 // Argument cannot be used for parameter due to differences in the nullability of reference types.
        }
    }
    public class FirstOrDefaultExpressionParser : ExpressionParserBase
    {
        public FirstOrDefaultExpressionParser() : base(@"FirstOrDefault")
        {
        }

        protected override CrossCutting.Common.Results.Result<ExpressionFramework.Domain.Expression> DoParse(CrossCutting.Utilities.Parsers.FunctionParseResult functionParseResult, CrossCutting.Utilities.Parsers.Contracts.IFunctionParseResultEvaluator evaluator, CrossCutting.Utilities.Parsers.Contracts.IExpressionParser parser)
        {
            #pragma warning disable CS8620 // Argument cannot be used for parameter due to differences in the nullability of reference types.
            return Result.Success<ExpressionFramework.Domain.Expression>(new ExpressionFramework.Domain.Expressions.FirstOrDefaultExpression(
    functionParseResult.GetTypedExpressionsArgumentValueExpression(0, @"Expression", evaluator, parser),
    functionParseResult.GetArgumentBooleanValueExpression(1, @"PredicateExpression", evaluator, parser, default),
    new TypedConstantResultExpression<System.Object?>(functionParseResult.GetArgumentValueResult(2, @"DefaultExpression", functionParseResult.Context, evaluator, parser, default))));
            #pragma warning restore CS8620 // Argument cannot be used for parameter due to differences in the nullability of reference types.
        }
    }
    public class GroupByExpressionParser : ExpressionParserBase
    {
        public GroupByExpressionParser() : base(@"GroupBy")
        {
        }

        protected override CrossCutting.Common.Results.Result<ExpressionFramework.Domain.Expression> DoParse(CrossCutting.Utilities.Parsers.FunctionParseResult functionParseResult, CrossCutting.Utilities.Parsers.Contracts.IFunctionParseResultEvaluator evaluator, CrossCutting.Utilities.Parsers.Contracts.IExpressionParser parser)
        {
            #pragma warning disable CS8620 // Argument cannot be used for parameter due to differences in the nullability of reference types.
            return Result.Success<ExpressionFramework.Domain.Expression>(new ExpressionFramework.Domain.Expressions.GroupByExpression(
    functionParseResult.GetTypedExpressionsArgumentValueExpression(0, @"Expression", evaluator, parser),
    new TypedConstantResultExpression<System.Object>(functionParseResult.GetArgumentValueResult(1, @"KeySelectorExpression", functionParseResult.Context, evaluator, parser))));
            #pragma warning restore CS8620 // Argument cannot be used for parameter due to differences in the nullability of reference types.
        }
    }
    public class IfExpressionParser : ExpressionParserBase
    {
        public IfExpressionParser() : base(@"If")
        {
        }

        protected override CrossCutting.Common.Results.Result<ExpressionFramework.Domain.Expression> DoParse(CrossCutting.Utilities.Parsers.FunctionParseResult functionParseResult, CrossCutting.Utilities.Parsers.Contracts.IFunctionParseResultEvaluator evaluator, CrossCutting.Utilities.Parsers.Contracts.IExpressionParser parser)
        {
            var conditionResult = functionParseResult.GetArgumentExpressionResult<ExpressionFramework.Domain.Evaluatable>(0, @"Condition", functionParseResult.Context, evaluator, parser);
            var error = new Result[]
            {
                conditionResult,
            }.FirstOrDefault(x => !x.IsSuccessful());
            if (error != null)
            {
                return Result.FromExistingResult<ExpressionFramework.Domain.Expression>(error);
            }
            #pragma warning disable CS8620 // Argument cannot be used for parameter due to differences in the nullability of reference types.
            return Result.Success<ExpressionFramework.Domain.Expression>(new ExpressionFramework.Domain.Expressions.IfExpression(
    conditionResult.Value!,
    new TypedConstantResultExpression<System.Object>(functionParseResult.GetArgumentValueResult(1, @"ResultExpression", functionParseResult.Context, evaluator, parser)),
    new TypedConstantResultExpression<System.Object?>(functionParseResult.GetArgumentValueResult(2, @"DefaultExpression", functionParseResult.Context, evaluator, parser, default))));
            #pragma warning restore CS8620 // Argument cannot be used for parameter due to differences in the nullability of reference types.
        }
    }
    public class InvalidExpressionParser : ExpressionParserBase
    {
        public InvalidExpressionParser() : base(@"Invalid")
        {
        }

        protected override CrossCutting.Common.Results.Result<ExpressionFramework.Domain.Expression> DoParse(CrossCutting.Utilities.Parsers.FunctionParseResult functionParseResult, CrossCutting.Utilities.Parsers.Contracts.IFunctionParseResultEvaluator evaluator, CrossCutting.Utilities.Parsers.Contracts.IExpressionParser parser)
        {
            var validationErrorExpressionsResult = functionParseResult.GetArgumentExpressionResult<System.Collections.Generic.IEnumerable<ExpressionFramework.Domain.Contracts.ITypedExpression<CrossCutting.Common.Results.ValidationError>>>(1, @"ValidationErrorExpressions", functionParseResult.Context, evaluator, parser);
            var error = new Result[]
            {
                validationErrorExpressionsResult,
            }.FirstOrDefault(x => !x.IsSuccessful());
            if (error != null)
            {
                return Result.FromExistingResult<ExpressionFramework.Domain.Expression>(error);
            }
            #pragma warning disable CS8620 // Argument cannot be used for parameter due to differences in the nullability of reference types.
            return Result.Success<ExpressionFramework.Domain.Expression>(new ExpressionFramework.Domain.Expressions.InvalidExpression(
    functionParseResult.GetArgumentStringValueExpression(0, @"ErrorMessageExpression", evaluator, parser),
    validationErrorExpressionsResult.Value!));
            #pragma warning restore CS8620 // Argument cannot be used for parameter due to differences in the nullability of reference types.
        }
    }
    public class LastExpressionParser : ExpressionParserBase
    {
        public LastExpressionParser() : base(@"Last")
        {
        }

        protected override CrossCutting.Common.Results.Result<ExpressionFramework.Domain.Expression> DoParse(CrossCutting.Utilities.Parsers.FunctionParseResult functionParseResult, CrossCutting.Utilities.Parsers.Contracts.IFunctionParseResultEvaluator evaluator, CrossCutting.Utilities.Parsers.Contracts.IExpressionParser parser)
        {
            #pragma warning disable CS8620 // Argument cannot be used for parameter due to differences in the nullability of reference types.
            return Result.Success<ExpressionFramework.Domain.Expression>(new ExpressionFramework.Domain.Expressions.LastExpression(
    functionParseResult.GetTypedExpressionsArgumentValueExpression(0, @"Expression", evaluator, parser),
    functionParseResult.GetArgumentBooleanValueExpression(1, @"PredicateExpression", evaluator, parser, default)));
            #pragma warning restore CS8620 // Argument cannot be used for parameter due to differences in the nullability of reference types.
        }
    }
    public class LastOrDefaultExpressionParser : ExpressionParserBase
    {
        public LastOrDefaultExpressionParser() : base(@"LastOrDefault")
        {
        }

        protected override CrossCutting.Common.Results.Result<ExpressionFramework.Domain.Expression> DoParse(CrossCutting.Utilities.Parsers.FunctionParseResult functionParseResult, CrossCutting.Utilities.Parsers.Contracts.IFunctionParseResultEvaluator evaluator, CrossCutting.Utilities.Parsers.Contracts.IExpressionParser parser)
        {
            #pragma warning disable CS8620 // Argument cannot be used for parameter due to differences in the nullability of reference types.
            return Result.Success<ExpressionFramework.Domain.Expression>(new ExpressionFramework.Domain.Expressions.LastOrDefaultExpression(
    functionParseResult.GetTypedExpressionsArgumentValueExpression(0, @"Expression", evaluator, parser),
    functionParseResult.GetArgumentBooleanValueExpression(1, @"PredicateExpression", evaluator, parser, default),
    new TypedConstantResultExpression<System.Object?>(functionParseResult.GetArgumentValueResult(2, @"DefaultExpression", functionParseResult.Context, evaluator, parser, default))));
            #pragma warning restore CS8620 // Argument cannot be used for parameter due to differences in the nullability of reference types.
        }
    }
    public class LeftExpressionParser : ExpressionParserBase
    {
        public LeftExpressionParser() : base(@"Left")
        {
        }

        protected override CrossCutting.Common.Results.Result<ExpressionFramework.Domain.Expression> DoParse(CrossCutting.Utilities.Parsers.FunctionParseResult functionParseResult, CrossCutting.Utilities.Parsers.Contracts.IFunctionParseResultEvaluator evaluator, CrossCutting.Utilities.Parsers.Contracts.IExpressionParser parser)
        {
            #pragma warning disable CS8620 // Argument cannot be used for parameter due to differences in the nullability of reference types.
            return Result.Success<ExpressionFramework.Domain.Expression>(new ExpressionFramework.Domain.Expressions.LeftExpression(
    functionParseResult.GetArgumentStringValueExpression(0, @"Expression", evaluator, parser),
    functionParseResult.GetArgumentInt32ValueExpression(1, @"LengthExpression", evaluator, parser)));
            #pragma warning restore CS8620 // Argument cannot be used for parameter due to differences in the nullability of reference types.
        }
    }
    public class MaxExpressionParser : ExpressionParserBase
    {
        public MaxExpressionParser() : base(@"Max")
        {
        }

        protected override CrossCutting.Common.Results.Result<ExpressionFramework.Domain.Expression> DoParse(CrossCutting.Utilities.Parsers.FunctionParseResult functionParseResult, CrossCutting.Utilities.Parsers.Contracts.IFunctionParseResultEvaluator evaluator, CrossCutting.Utilities.Parsers.Contracts.IExpressionParser parser)
        {
            #pragma warning disable CS8620 // Argument cannot be used for parameter due to differences in the nullability of reference types.
            return Result.Success<ExpressionFramework.Domain.Expression>(new ExpressionFramework.Domain.Expressions.MaxExpression(
    functionParseResult.GetTypedExpressionsArgumentValueExpression(0, @"Expression", evaluator, parser),
    new TypedConstantResultExpression<System.Object?>(functionParseResult.GetArgumentValueResult(1, @"SelectorExpression", functionParseResult.Context, evaluator, parser, default))));
            #pragma warning restore CS8620 // Argument cannot be used for parameter due to differences in the nullability of reference types.
        }
    }
    public class MinExpressionParser : ExpressionParserBase
    {
        public MinExpressionParser() : base(@"Min")
        {
        }

        protected override CrossCutting.Common.Results.Result<ExpressionFramework.Domain.Expression> DoParse(CrossCutting.Utilities.Parsers.FunctionParseResult functionParseResult, CrossCutting.Utilities.Parsers.Contracts.IFunctionParseResultEvaluator evaluator, CrossCutting.Utilities.Parsers.Contracts.IExpressionParser parser)
        {
            #pragma warning disable CS8620 // Argument cannot be used for parameter due to differences in the nullability of reference types.
            return Result.Success<ExpressionFramework.Domain.Expression>(new ExpressionFramework.Domain.Expressions.MinExpression(
    functionParseResult.GetTypedExpressionsArgumentValueExpression(0, @"Expression", evaluator, parser),
    new TypedConstantResultExpression<System.Object?>(functionParseResult.GetArgumentValueResult(1, @"SelectorExpression", functionParseResult.Context, evaluator, parser, default))));
            #pragma warning restore CS8620 // Argument cannot be used for parameter due to differences in the nullability of reference types.
        }
    }
    public class MonthExpressionParser : ExpressionParserBase
    {
        public MonthExpressionParser() : base(@"Month")
        {
        }

        protected override CrossCutting.Common.Results.Result<ExpressionFramework.Domain.Expression> DoParse(CrossCutting.Utilities.Parsers.FunctionParseResult functionParseResult, CrossCutting.Utilities.Parsers.Contracts.IFunctionParseResultEvaluator evaluator, CrossCutting.Utilities.Parsers.Contracts.IExpressionParser parser)
        {
            #pragma warning disable CS8620 // Argument cannot be used for parameter due to differences in the nullability of reference types.
            return Result.Success<ExpressionFramework.Domain.Expression>(new ExpressionFramework.Domain.Expressions.MonthExpression(
    functionParseResult.GetArgumentDateTimeValueExpression(0, @"Expression", evaluator, parser)));
            #pragma warning restore CS8620 // Argument cannot be used for parameter due to differences in the nullability of reference types.
        }
    }
    public class NotEqualsExpressionParser : ExpressionParserBase
    {
        public NotEqualsExpressionParser() : base(@"NotEquals")
        {
        }

        protected override CrossCutting.Common.Results.Result<ExpressionFramework.Domain.Expression> DoParse(CrossCutting.Utilities.Parsers.FunctionParseResult functionParseResult, CrossCutting.Utilities.Parsers.Contracts.IFunctionParseResultEvaluator evaluator, CrossCutting.Utilities.Parsers.Contracts.IExpressionParser parser)
        {
            #pragma warning disable CS8620 // Argument cannot be used for parameter due to differences in the nullability of reference types.
            return Result.Success<ExpressionFramework.Domain.Expression>(new ExpressionFramework.Domain.Expressions.NotEqualsExpression(
    new TypedConstantResultExpression<System.Object>(functionParseResult.GetArgumentValueResult(0, @"FirstExpression", functionParseResult.Context, evaluator, parser)),
    new TypedConstantResultExpression<System.Object>(functionParseResult.GetArgumentValueResult(1, @"SecondExpression", functionParseResult.Context, evaluator, parser))));
            #pragma warning restore CS8620 // Argument cannot be used for parameter due to differences in the nullability of reference types.
        }
    }
    public class NotExpressionParser : ExpressionParserBase
    {
        public NotExpressionParser() : base(@"Not")
        {
        }

        protected override CrossCutting.Common.Results.Result<ExpressionFramework.Domain.Expression> DoParse(CrossCutting.Utilities.Parsers.FunctionParseResult functionParseResult, CrossCutting.Utilities.Parsers.Contracts.IFunctionParseResultEvaluator evaluator, CrossCutting.Utilities.Parsers.Contracts.IExpressionParser parser)
        {
            #pragma warning disable CS8620 // Argument cannot be used for parameter due to differences in the nullability of reference types.
            return Result.Success<ExpressionFramework.Domain.Expression>(new ExpressionFramework.Domain.Expressions.NotExpression(
    functionParseResult.GetArgumentBooleanValueExpression(0, @"Expression", evaluator, parser)));
            #pragma warning restore CS8620 // Argument cannot be used for parameter due to differences in the nullability of reference types.
        }
    }
    public class NowExpressionParser : ExpressionParserBase
    {
        public NowExpressionParser() : base(@"Now")
        {
        }

        protected override CrossCutting.Common.Results.Result<ExpressionFramework.Domain.Expression> DoParse(CrossCutting.Utilities.Parsers.FunctionParseResult functionParseResult, CrossCutting.Utilities.Parsers.Contracts.IFunctionParseResultEvaluator evaluator, CrossCutting.Utilities.Parsers.Contracts.IExpressionParser parser)
        {
            var dateTimeProviderResult = functionParseResult.GetArgumentExpressionResult<CrossCutting.Common.Abstractions.IDateTimeProvider>(0, @"DateTimeProvider", functionParseResult.Context, evaluator, parser, default);
            var error = new Result[]
            {
                dateTimeProviderResult,
            }.FirstOrDefault(x => !x.IsSuccessful());
            if (error != null)
            {
                return Result.FromExistingResult<ExpressionFramework.Domain.Expression>(error);
            }
            #pragma warning disable CS8620 // Argument cannot be used for parameter due to differences in the nullability of reference types.
            return Result.Success<ExpressionFramework.Domain.Expression>(new ExpressionFramework.Domain.Expressions.NowExpression(
    dateTimeProviderResult.Value));
            #pragma warning restore CS8620 // Argument cannot be used for parameter due to differences in the nullability of reference types.
        }
    }
    public class OfTypeExpressionParser : ExpressionParserBase
    {
        public OfTypeExpressionParser() : base(@"OfType")
        {
        }

        protected override CrossCutting.Common.Results.Result<ExpressionFramework.Domain.Expression> DoParse(CrossCutting.Utilities.Parsers.FunctionParseResult functionParseResult, CrossCutting.Utilities.Parsers.Contracts.IFunctionParseResultEvaluator evaluator, CrossCutting.Utilities.Parsers.Contracts.IExpressionParser parser)
        {
            #pragma warning disable CS8620 // Argument cannot be used for parameter due to differences in the nullability of reference types.
            return Result.Success<ExpressionFramework.Domain.Expression>(new ExpressionFramework.Domain.Expressions.OfTypeExpression(
    functionParseResult.GetTypedExpressionsArgumentValueExpression(0, @"Expression", evaluator, parser),
    functionParseResult.GetArgumentValueExpression<System.Type>(1, @"TypeExpression", evaluator, parser)));
            #pragma warning restore CS8620 // Argument cannot be used for parameter due to differences in the nullability of reference types.
        }
    }
    public class OperatorExpressionParser : ExpressionParserBase
    {
        public OperatorExpressionParser() : base(@"Operator")
        {
        }

        protected override CrossCutting.Common.Results.Result<ExpressionFramework.Domain.Expression> DoParse(CrossCutting.Utilities.Parsers.FunctionParseResult functionParseResult, CrossCutting.Utilities.Parsers.Contracts.IFunctionParseResultEvaluator evaluator, CrossCutting.Utilities.Parsers.Contracts.IExpressionParser parser)
        {
            var operatorResult = functionParseResult.GetArgumentExpressionResult<ExpressionFramework.Domain.Operator>(2, @"Operator", functionParseResult.Context, evaluator, parser);
            var error = new Result[]
            {
                operatorResult,
            }.FirstOrDefault(x => !x.IsSuccessful());
            if (error != null)
            {
                return Result.FromExistingResult<ExpressionFramework.Domain.Expression>(error);
            }
            #pragma warning disable CS8620 // Argument cannot be used for parameter due to differences in the nullability of reference types.
            return Result.Success<ExpressionFramework.Domain.Expression>(new ExpressionFramework.Domain.Expressions.OperatorExpression(
    new TypedConstantResultExpression<System.Object>(functionParseResult.GetArgumentValueResult(0, @"LeftExpression", functionParseResult.Context, evaluator, parser)),
    new TypedConstantResultExpression<System.Object>(functionParseResult.GetArgumentValueResult(1, @"RightExpression", functionParseResult.Context, evaluator, parser)),
    operatorResult.Value!));
            #pragma warning restore CS8620 // Argument cannot be used for parameter due to differences in the nullability of reference types.
        }
    }
    public class OrderByExpressionParser : ExpressionParserBase
    {
        public OrderByExpressionParser() : base(@"OrderBy")
        {
        }

        protected override CrossCutting.Common.Results.Result<ExpressionFramework.Domain.Expression> DoParse(CrossCutting.Utilities.Parsers.FunctionParseResult functionParseResult, CrossCutting.Utilities.Parsers.Contracts.IFunctionParseResultEvaluator evaluator, CrossCutting.Utilities.Parsers.Contracts.IExpressionParser parser)
        {
            var sortOrderExpressionsResult = functionParseResult.GetArgumentExpressionResult<System.Collections.Generic.IEnumerable<ExpressionFramework.Domain.Contracts.ITypedExpression<ExpressionFramework.Domain.SortOrder>>>(1, @"SortOrderExpressions", functionParseResult.Context, evaluator, parser);
            var error = new Result[]
            {
                sortOrderExpressionsResult,
            }.FirstOrDefault(x => !x.IsSuccessful());
            if (error != null)
            {
                return Result.FromExistingResult<ExpressionFramework.Domain.Expression>(error);
            }
            #pragma warning disable CS8620 // Argument cannot be used for parameter due to differences in the nullability of reference types.
            return Result.Success<ExpressionFramework.Domain.Expression>(new ExpressionFramework.Domain.Expressions.OrderByExpression(
    functionParseResult.GetTypedExpressionsArgumentValueExpression(0, @"Expression", evaluator, parser),
    sortOrderExpressionsResult.Value!));
            #pragma warning restore CS8620 // Argument cannot be used for parameter due to differences in the nullability of reference types.
        }
    }
    public class OrExpressionParser : ExpressionParserBase
    {
        public OrExpressionParser() : base(@"Or")
        {
        }

        protected override CrossCutting.Common.Results.Result<ExpressionFramework.Domain.Expression> DoParse(CrossCutting.Utilities.Parsers.FunctionParseResult functionParseResult, CrossCutting.Utilities.Parsers.Contracts.IFunctionParseResultEvaluator evaluator, CrossCutting.Utilities.Parsers.Contracts.IExpressionParser parser)
        {
            #pragma warning disable CS8620 // Argument cannot be used for parameter due to differences in the nullability of reference types.
            return Result.Success<ExpressionFramework.Domain.Expression>(new ExpressionFramework.Domain.Expressions.OrExpression(
    functionParseResult.GetArgumentBooleanValueExpression(0, @"FirstExpression", evaluator, parser),
    functionParseResult.GetArgumentBooleanValueExpression(1, @"SecondExpression", evaluator, parser)));
            #pragma warning restore CS8620 // Argument cannot be used for parameter due to differences in the nullability of reference types.
        }
    }
    public class RightExpressionParser : ExpressionParserBase
    {
        public RightExpressionParser() : base(@"Right")
        {
        }

        protected override CrossCutting.Common.Results.Result<ExpressionFramework.Domain.Expression> DoParse(CrossCutting.Utilities.Parsers.FunctionParseResult functionParseResult, CrossCutting.Utilities.Parsers.Contracts.IFunctionParseResultEvaluator evaluator, CrossCutting.Utilities.Parsers.Contracts.IExpressionParser parser)
        {
            #pragma warning disable CS8620 // Argument cannot be used for parameter due to differences in the nullability of reference types.
            return Result.Success<ExpressionFramework.Domain.Expression>(new ExpressionFramework.Domain.Expressions.RightExpression(
    functionParseResult.GetArgumentStringValueExpression(0, @"Expression", evaluator, parser),
    functionParseResult.GetArgumentInt32ValueExpression(1, @"LengthExpression", evaluator, parser)));
            #pragma warning restore CS8620 // Argument cannot be used for parameter due to differences in the nullability of reference types.
        }
    }
    public class SelectExpressionParser : ExpressionParserBase
    {
        public SelectExpressionParser() : base(@"Select")
        {
        }

        protected override CrossCutting.Common.Results.Result<ExpressionFramework.Domain.Expression> DoParse(CrossCutting.Utilities.Parsers.FunctionParseResult functionParseResult, CrossCutting.Utilities.Parsers.Contracts.IFunctionParseResultEvaluator evaluator, CrossCutting.Utilities.Parsers.Contracts.IExpressionParser parser)
        {
            #pragma warning disable CS8620 // Argument cannot be used for parameter due to differences in the nullability of reference types.
            return Result.Success<ExpressionFramework.Domain.Expression>(new ExpressionFramework.Domain.Expressions.SelectExpression(
    functionParseResult.GetTypedExpressionsArgumentValueExpression(0, @"Expression", evaluator, parser),
    new TypedConstantResultExpression<System.Object>(functionParseResult.GetArgumentValueResult(1, @"SelectorExpression", functionParseResult.Context, evaluator, parser))));
            #pragma warning restore CS8620 // Argument cannot be used for parameter due to differences in the nullability of reference types.
        }
    }
    public class SequenceExpressionParser : ExpressionParserBase
    {
        public SequenceExpressionParser() : base(@"Sequence")
        {
        }

        protected override CrossCutting.Common.Results.Result<ExpressionFramework.Domain.Expression> DoParse(CrossCutting.Utilities.Parsers.FunctionParseResult functionParseResult, CrossCutting.Utilities.Parsers.Contracts.IFunctionParseResultEvaluator evaluator, CrossCutting.Utilities.Parsers.Contracts.IExpressionParser parser)
        {
            #pragma warning disable CS8620 // Argument cannot be used for parameter due to differences in the nullability of reference types.
            return Result.Success<ExpressionFramework.Domain.Expression>(new ExpressionFramework.Domain.Expressions.SequenceExpression(
    functionParseResult.GetExpressionsArgumentValueResult(0, @"Expressions", evaluator, parser)));
            #pragma warning restore CS8620 // Argument cannot be used for parameter due to differences in the nullability of reference types.
        }
    }
    public class SingleExpressionParser : ExpressionParserBase
    {
        public SingleExpressionParser() : base(@"Single")
        {
        }

        protected override CrossCutting.Common.Results.Result<ExpressionFramework.Domain.Expression> DoParse(CrossCutting.Utilities.Parsers.FunctionParseResult functionParseResult, CrossCutting.Utilities.Parsers.Contracts.IFunctionParseResultEvaluator evaluator, CrossCutting.Utilities.Parsers.Contracts.IExpressionParser parser)
        {
            #pragma warning disable CS8620 // Argument cannot be used for parameter due to differences in the nullability of reference types.
            return Result.Success<ExpressionFramework.Domain.Expression>(new ExpressionFramework.Domain.Expressions.SingleExpression(
    functionParseResult.GetTypedExpressionsArgumentValueExpression(0, @"Expression", evaluator, parser),
    functionParseResult.GetArgumentBooleanValueExpression(1, @"PredicateExpression", evaluator, parser, default)));
            #pragma warning restore CS8620 // Argument cannot be used for parameter due to differences in the nullability of reference types.
        }
    }
    public class SingleOrDefaultExpressionParser : ExpressionParserBase
    {
        public SingleOrDefaultExpressionParser() : base(@"SingleOrDefault")
        {
        }

        protected override CrossCutting.Common.Results.Result<ExpressionFramework.Domain.Expression> DoParse(CrossCutting.Utilities.Parsers.FunctionParseResult functionParseResult, CrossCutting.Utilities.Parsers.Contracts.IFunctionParseResultEvaluator evaluator, CrossCutting.Utilities.Parsers.Contracts.IExpressionParser parser)
        {
            #pragma warning disable CS8620 // Argument cannot be used for parameter due to differences in the nullability of reference types.
            return Result.Success<ExpressionFramework.Domain.Expression>(new ExpressionFramework.Domain.Expressions.SingleOrDefaultExpression(
    functionParseResult.GetTypedExpressionsArgumentValueExpression(0, @"Expression", evaluator, parser),
    functionParseResult.GetArgumentBooleanValueExpression(1, @"PredicateExpression", evaluator, parser, default),
    new TypedConstantResultExpression<System.Object?>(functionParseResult.GetArgumentValueResult(2, @"DefaultExpression", functionParseResult.Context, evaluator, parser, default))));
            #pragma warning restore CS8620 // Argument cannot be used for parameter due to differences in the nullability of reference types.
        }
    }
    public class SkipExpressionParser : ExpressionParserBase
    {
        public SkipExpressionParser() : base(@"Skip")
        {
        }

        protected override CrossCutting.Common.Results.Result<ExpressionFramework.Domain.Expression> DoParse(CrossCutting.Utilities.Parsers.FunctionParseResult functionParseResult, CrossCutting.Utilities.Parsers.Contracts.IFunctionParseResultEvaluator evaluator, CrossCutting.Utilities.Parsers.Contracts.IExpressionParser parser)
        {
            #pragma warning disable CS8620 // Argument cannot be used for parameter due to differences in the nullability of reference types.
            return Result.Success<ExpressionFramework.Domain.Expression>(new ExpressionFramework.Domain.Expressions.SkipExpression(
    functionParseResult.GetTypedExpressionsArgumentValueExpression(0, @"Expression", evaluator, parser),
    functionParseResult.GetArgumentInt32ValueExpression(1, @"CountExpression", evaluator, parser)));
            #pragma warning restore CS8620 // Argument cannot be used for parameter due to differences in the nullability of reference types.
        }
    }
    public class StringConcatenateExpressionParser : ExpressionParserBase
    {
        public StringConcatenateExpressionParser() : base(@"StringConcatenate")
        {
        }

        protected override CrossCutting.Common.Results.Result<ExpressionFramework.Domain.Expression> DoParse(CrossCutting.Utilities.Parsers.FunctionParseResult functionParseResult, CrossCutting.Utilities.Parsers.Contracts.IFunctionParseResultEvaluator evaluator, CrossCutting.Utilities.Parsers.Contracts.IExpressionParser parser)
        {
            var expressionsResult = functionParseResult.GetArgumentExpressionResult<System.Collections.Generic.IEnumerable<ExpressionFramework.Domain.Contracts.ITypedExpression<System.String>>>(0, @"Expressions", functionParseResult.Context, evaluator, parser);
            var error = new Result[]
            {
                expressionsResult,
            }.FirstOrDefault(x => !x.IsSuccessful());
            if (error != null)
            {
                return Result.FromExistingResult<ExpressionFramework.Domain.Expression>(error);
            }
            #pragma warning disable CS8620 // Argument cannot be used for parameter due to differences in the nullability of reference types.
            return Result.Success<ExpressionFramework.Domain.Expression>(new ExpressionFramework.Domain.Expressions.StringConcatenateExpression(
    expressionsResult.Value!));
            #pragma warning restore CS8620 // Argument cannot be used for parameter due to differences in the nullability of reference types.
        }
    }
    public class StringFindExpressionParser : ExpressionParserBase
    {
        public StringFindExpressionParser() : base(@"StringFind")
        {
        }

        protected override CrossCutting.Common.Results.Result<ExpressionFramework.Domain.Expression> DoParse(CrossCutting.Utilities.Parsers.FunctionParseResult functionParseResult, CrossCutting.Utilities.Parsers.Contracts.IFunctionParseResultEvaluator evaluator, CrossCutting.Utilities.Parsers.Contracts.IExpressionParser parser)
        {
            #pragma warning disable CS8620 // Argument cannot be used for parameter due to differences in the nullability of reference types.
            return Result.Success<ExpressionFramework.Domain.Expression>(new ExpressionFramework.Domain.Expressions.StringFindExpression(
    functionParseResult.GetArgumentStringValueExpression(0, @"Expression", evaluator, parser),
    functionParseResult.GetArgumentStringValueExpression(1, @"FindExpression", evaluator, parser)));
            #pragma warning restore CS8620 // Argument cannot be used for parameter due to differences in the nullability of reference types.
        }
    }
    public class StringLengthExpressionParser : ExpressionParserBase
    {
        public StringLengthExpressionParser() : base(@"StringLength")
        {
        }

        protected override CrossCutting.Common.Results.Result<ExpressionFramework.Domain.Expression> DoParse(CrossCutting.Utilities.Parsers.FunctionParseResult functionParseResult, CrossCutting.Utilities.Parsers.Contracts.IFunctionParseResultEvaluator evaluator, CrossCutting.Utilities.Parsers.Contracts.IExpressionParser parser)
        {
            #pragma warning disable CS8620 // Argument cannot be used for parameter due to differences in the nullability of reference types.
            return Result.Success<ExpressionFramework.Domain.Expression>(new ExpressionFramework.Domain.Expressions.StringLengthExpression(
    functionParseResult.GetArgumentStringValueExpression(0, @"Expression", evaluator, parser)));
            #pragma warning restore CS8620 // Argument cannot be used for parameter due to differences in the nullability of reference types.
        }
    }
    public class StringReplaceExpressionParser : ExpressionParserBase
    {
        public StringReplaceExpressionParser() : base(@"StringReplace")
        {
        }

        protected override CrossCutting.Common.Results.Result<ExpressionFramework.Domain.Expression> DoParse(CrossCutting.Utilities.Parsers.FunctionParseResult functionParseResult, CrossCutting.Utilities.Parsers.Contracts.IFunctionParseResultEvaluator evaluator, CrossCutting.Utilities.Parsers.Contracts.IExpressionParser parser)
        {
            #pragma warning disable CS8620 // Argument cannot be used for parameter due to differences in the nullability of reference types.
            return Result.Success<ExpressionFramework.Domain.Expression>(new ExpressionFramework.Domain.Expressions.StringReplaceExpression(
    functionParseResult.GetArgumentStringValueExpression(0, @"Expression", evaluator, parser),
    functionParseResult.GetArgumentStringValueExpression(1, @"FindExpression", evaluator, parser),
    functionParseResult.GetArgumentStringValueExpression(2, @"ReplaceExpression", evaluator, parser)));
            #pragma warning restore CS8620 // Argument cannot be used for parameter due to differences in the nullability of reference types.
        }
    }
    public class SubstringExpressionParser : ExpressionParserBase
    {
        public SubstringExpressionParser() : base(@"Substring")
        {
        }

        protected override CrossCutting.Common.Results.Result<ExpressionFramework.Domain.Expression> DoParse(CrossCutting.Utilities.Parsers.FunctionParseResult functionParseResult, CrossCutting.Utilities.Parsers.Contracts.IFunctionParseResultEvaluator evaluator, CrossCutting.Utilities.Parsers.Contracts.IExpressionParser parser)
        {
            #pragma warning disable CS8620 // Argument cannot be used for parameter due to differences in the nullability of reference types.
            return Result.Success<ExpressionFramework.Domain.Expression>(new ExpressionFramework.Domain.Expressions.SubstringExpression(
    functionParseResult.GetArgumentStringValueExpression(0, @"Expression", evaluator, parser),
    functionParseResult.GetArgumentInt32ValueExpression(1, @"IndexExpression", evaluator, parser),
    functionParseResult.GetArgumentInt32ValueExpression(2, @"LengthExpression", evaluator, parser, default)));
            #pragma warning restore CS8620 // Argument cannot be used for parameter due to differences in the nullability of reference types.
        }
    }
    public class SumExpressionParser : ExpressionParserBase
    {
        public SumExpressionParser() : base(@"Sum")
        {
        }

        protected override CrossCutting.Common.Results.Result<ExpressionFramework.Domain.Expression> DoParse(CrossCutting.Utilities.Parsers.FunctionParseResult functionParseResult, CrossCutting.Utilities.Parsers.Contracts.IFunctionParseResultEvaluator evaluator, CrossCutting.Utilities.Parsers.Contracts.IExpressionParser parser)
        {
            #pragma warning disable CS8620 // Argument cannot be used for parameter due to differences in the nullability of reference types.
            return Result.Success<ExpressionFramework.Domain.Expression>(new ExpressionFramework.Domain.Expressions.SumExpression(
    functionParseResult.GetTypedExpressionsArgumentValueExpression(0, @"Expression", evaluator, parser),
    new TypedConstantResultExpression<System.Object?>(functionParseResult.GetArgumentValueResult(1, @"SelectorExpression", functionParseResult.Context, evaluator, parser, default))));
            #pragma warning restore CS8620 // Argument cannot be used for parameter due to differences in the nullability of reference types.
        }
    }
    public class SwitchExpressionParser : ExpressionParserBase
    {
        public SwitchExpressionParser() : base(@"Switch")
        {
        }

        protected override CrossCutting.Common.Results.Result<ExpressionFramework.Domain.Expression> DoParse(CrossCutting.Utilities.Parsers.FunctionParseResult functionParseResult, CrossCutting.Utilities.Parsers.Contracts.IFunctionParseResultEvaluator evaluator, CrossCutting.Utilities.Parsers.Contracts.IExpressionParser parser)
        {
            var casesResult = functionParseResult.GetArgumentExpressionResult<System.Collections.Generic.IEnumerable<ExpressionFramework.Domain.Case>>(0, @"Cases", functionParseResult.Context, evaluator, parser);
            var error = new Result[]
            {
                casesResult,
            }.FirstOrDefault(x => !x.IsSuccessful());
            if (error != null)
            {
                return Result.FromExistingResult<ExpressionFramework.Domain.Expression>(error);
            }
            #pragma warning disable CS8620 // Argument cannot be used for parameter due to differences in the nullability of reference types.
            return Result.Success<ExpressionFramework.Domain.Expression>(new ExpressionFramework.Domain.Expressions.SwitchExpression(
    casesResult.Value!,
    new TypedConstantResultExpression<System.Object?>(functionParseResult.GetArgumentValueResult(1, @"DefaultExpression", functionParseResult.Context, evaluator, parser, default))));
            #pragma warning restore CS8620 // Argument cannot be used for parameter due to differences in the nullability of reference types.
        }
    }
    public class TakeExpressionParser : ExpressionParserBase
    {
        public TakeExpressionParser() : base(@"Take")
        {
        }

        protected override CrossCutting.Common.Results.Result<ExpressionFramework.Domain.Expression> DoParse(CrossCutting.Utilities.Parsers.FunctionParseResult functionParseResult, CrossCutting.Utilities.Parsers.Contracts.IFunctionParseResultEvaluator evaluator, CrossCutting.Utilities.Parsers.Contracts.IExpressionParser parser)
        {
            #pragma warning disable CS8620 // Argument cannot be used for parameter due to differences in the nullability of reference types.
            return Result.Success<ExpressionFramework.Domain.Expression>(new ExpressionFramework.Domain.Expressions.TakeExpression(
    functionParseResult.GetTypedExpressionsArgumentValueExpression(0, @"Expression", evaluator, parser),
    functionParseResult.GetArgumentInt32ValueExpression(1, @"CountExpression", evaluator, parser)));
            #pragma warning restore CS8620 // Argument cannot be used for parameter due to differences in the nullability of reference types.
        }
    }
    public class TodayExpressionParser : ExpressionParserBase
    {
        public TodayExpressionParser() : base(@"Today")
        {
        }

        protected override CrossCutting.Common.Results.Result<ExpressionFramework.Domain.Expression> DoParse(CrossCutting.Utilities.Parsers.FunctionParseResult functionParseResult, CrossCutting.Utilities.Parsers.Contracts.IFunctionParseResultEvaluator evaluator, CrossCutting.Utilities.Parsers.Contracts.IExpressionParser parser)
        {
            var dateTimeProviderResult = functionParseResult.GetArgumentExpressionResult<CrossCutting.Common.Abstractions.IDateTimeProvider>(0, @"DateTimeProvider", functionParseResult.Context, evaluator, parser, default);
            var error = new Result[]
            {
                dateTimeProviderResult,
            }.FirstOrDefault(x => !x.IsSuccessful());
            if (error != null)
            {
                return Result.FromExistingResult<ExpressionFramework.Domain.Expression>(error);
            }
            #pragma warning disable CS8620 // Argument cannot be used for parameter due to differences in the nullability of reference types.
            return Result.Success<ExpressionFramework.Domain.Expression>(new ExpressionFramework.Domain.Expressions.TodayExpression(
    dateTimeProviderResult.Value));
            #pragma warning restore CS8620 // Argument cannot be used for parameter due to differences in the nullability of reference types.
        }
    }
    public class ToLowerCaseExpressionParser : ExpressionParserBase
    {
        public ToLowerCaseExpressionParser() : base(@"ToLowerCase")
        {
        }

        protected override CrossCutting.Common.Results.Result<ExpressionFramework.Domain.Expression> DoParse(CrossCutting.Utilities.Parsers.FunctionParseResult functionParseResult, CrossCutting.Utilities.Parsers.Contracts.IFunctionParseResultEvaluator evaluator, CrossCutting.Utilities.Parsers.Contracts.IExpressionParser parser)
        {
            #pragma warning disable CS8620 // Argument cannot be used for parameter due to differences in the nullability of reference types.
            return Result.Success<ExpressionFramework.Domain.Expression>(new ExpressionFramework.Domain.Expressions.ToLowerCaseExpression(
    functionParseResult.GetArgumentStringValueExpression(0, @"Expression", evaluator, parser)));
            #pragma warning restore CS8620 // Argument cannot be used for parameter due to differences in the nullability of reference types.
        }
    }
    public class ToPascalCaseExpressionParser : ExpressionParserBase
    {
        public ToPascalCaseExpressionParser() : base(@"ToPascalCase")
        {
        }

        protected override CrossCutting.Common.Results.Result<ExpressionFramework.Domain.Expression> DoParse(CrossCutting.Utilities.Parsers.FunctionParseResult functionParseResult, CrossCutting.Utilities.Parsers.Contracts.IFunctionParseResultEvaluator evaluator, CrossCutting.Utilities.Parsers.Contracts.IExpressionParser parser)
        {
            #pragma warning disable CS8620 // Argument cannot be used for parameter due to differences in the nullability of reference types.
            return Result.Success<ExpressionFramework.Domain.Expression>(new ExpressionFramework.Domain.Expressions.ToPascalCaseExpression(
    functionParseResult.GetArgumentStringValueExpression(0, @"Expression", evaluator, parser)));
            #pragma warning restore CS8620 // Argument cannot be used for parameter due to differences in the nullability of reference types.
        }
    }
    public class ToUpperCaseExpressionParser : ExpressionParserBase
    {
        public ToUpperCaseExpressionParser() : base(@"ToUpperCase")
        {
        }

        protected override CrossCutting.Common.Results.Result<ExpressionFramework.Domain.Expression> DoParse(CrossCutting.Utilities.Parsers.FunctionParseResult functionParseResult, CrossCutting.Utilities.Parsers.Contracts.IFunctionParseResultEvaluator evaluator, CrossCutting.Utilities.Parsers.Contracts.IExpressionParser parser)
        {
            #pragma warning disable CS8620 // Argument cannot be used for parameter due to differences in the nullability of reference types.
            return Result.Success<ExpressionFramework.Domain.Expression>(new ExpressionFramework.Domain.Expressions.ToUpperCaseExpression(
    functionParseResult.GetArgumentStringValueExpression(0, @"Expression", evaluator, parser)));
            #pragma warning restore CS8620 // Argument cannot be used for parameter due to differences in the nullability of reference types.
        }
    }
    public class TrimEndExpressionParser : ExpressionParserBase
    {
        public TrimEndExpressionParser() : base(@"TrimEnd")
        {
        }

        protected override CrossCutting.Common.Results.Result<ExpressionFramework.Domain.Expression> DoParse(CrossCutting.Utilities.Parsers.FunctionParseResult functionParseResult, CrossCutting.Utilities.Parsers.Contracts.IFunctionParseResultEvaluator evaluator, CrossCutting.Utilities.Parsers.Contracts.IExpressionParser parser)
        {
            #pragma warning disable CS8620 // Argument cannot be used for parameter due to differences in the nullability of reference types.
            return Result.Success<ExpressionFramework.Domain.Expression>(new ExpressionFramework.Domain.Expressions.TrimEndExpression(
    functionParseResult.GetArgumentStringValueExpression(0, @"Expression", evaluator, parser),
    functionParseResult.GetArgumentValueExpression<System.Char[]>(1, @"TrimCharsExpression", evaluator, parser, default)));
            #pragma warning restore CS8620 // Argument cannot be used for parameter due to differences in the nullability of reference types.
        }
    }
    public class TrimExpressionParser : ExpressionParserBase
    {
        public TrimExpressionParser() : base(@"Trim")
        {
        }

        protected override CrossCutting.Common.Results.Result<ExpressionFramework.Domain.Expression> DoParse(CrossCutting.Utilities.Parsers.FunctionParseResult functionParseResult, CrossCutting.Utilities.Parsers.Contracts.IFunctionParseResultEvaluator evaluator, CrossCutting.Utilities.Parsers.Contracts.IExpressionParser parser)
        {
            #pragma warning disable CS8620 // Argument cannot be used for parameter due to differences in the nullability of reference types.
            return Result.Success<ExpressionFramework.Domain.Expression>(new ExpressionFramework.Domain.Expressions.TrimExpression(
    functionParseResult.GetArgumentStringValueExpression(0, @"Expression", evaluator, parser),
    functionParseResult.GetArgumentValueExpression<System.Char[]>(1, @"TrimCharsExpression", evaluator, parser, default)));
            #pragma warning restore CS8620 // Argument cannot be used for parameter due to differences in the nullability of reference types.
        }
    }
    public class TrimStartExpressionParser : ExpressionParserBase
    {
        public TrimStartExpressionParser() : base(@"TrimStart")
        {
        }

        protected override CrossCutting.Common.Results.Result<ExpressionFramework.Domain.Expression> DoParse(CrossCutting.Utilities.Parsers.FunctionParseResult functionParseResult, CrossCutting.Utilities.Parsers.Contracts.IFunctionParseResultEvaluator evaluator, CrossCutting.Utilities.Parsers.Contracts.IExpressionParser parser)
        {
            #pragma warning disable CS8620 // Argument cannot be used for parameter due to differences in the nullability of reference types.
            return Result.Success<ExpressionFramework.Domain.Expression>(new ExpressionFramework.Domain.Expressions.TrimStartExpression(
    functionParseResult.GetArgumentStringValueExpression(0, @"Expression", evaluator, parser),
    functionParseResult.GetArgumentValueExpression<System.Char[]>(1, @"TrimCharsExpression", evaluator, parser, default)));
            #pragma warning restore CS8620 // Argument cannot be used for parameter due to differences in the nullability of reference types.
        }
    }
    public class TrueExpressionParser : ExpressionParserBase
    {
        public TrueExpressionParser() : base(@"True")
        {
        }

        protected override CrossCutting.Common.Results.Result<ExpressionFramework.Domain.Expression> DoParse(CrossCutting.Utilities.Parsers.FunctionParseResult functionParseResult, CrossCutting.Utilities.Parsers.Contracts.IFunctionParseResultEvaluator evaluator, CrossCutting.Utilities.Parsers.Contracts.IExpressionParser parser)
        {
            #pragma warning disable CS8620 // Argument cannot be used for parameter due to differences in the nullability of reference types.
            return Result.Success<ExpressionFramework.Domain.Expression>(new ExpressionFramework.Domain.Expressions.TrueExpression(
    ));
            #pragma warning restore CS8620 // Argument cannot be used for parameter due to differences in the nullability of reference types.
        }
    }
    public class TryCastExpressionParser : ExpressionParserBase
    {
        public TryCastExpressionParser() : base(@"TryCast")
        {
        }

        protected override CrossCutting.Common.Results.Result<ExpressionFramework.Domain.Expression> DoParse(CrossCutting.Utilities.Parsers.FunctionParseResult functionParseResult, CrossCutting.Utilities.Parsers.Contracts.IFunctionParseResultEvaluator evaluator, CrossCutting.Utilities.Parsers.Contracts.IExpressionParser parser)
        {
            var typeResult = functionParseResult.FunctionName.GetGenericTypeResult();
            if (!typeResult.IsSuccessful())
            {
                return Result.FromExistingResult<ExpressionFramework.Domain.Expression>(typeResult);
            }
            #pragma warning disable CS8620 // Argument cannot be used for parameter due to differences in the nullability of reference types.
            return Result.Success<ExpressionFramework.Domain.Expression>((ExpressionFramework.Domain.Expression)System.Activator.CreateInstance(typeof(ExpressionFramework.Domain.Expressions.TryCastExpression<>).MakeGenericType(typeResult.Value!)));
            #pragma warning restore CS8620 // Argument cannot be used for parameter due to differences in the nullability of reference types.
        }

        protected override bool IsNameValid(string functionName)
        {
            return base.IsNameValid(functionName.WithoutGenerics());
        }
    }
    public class TypedChainedExpressionParser : ExpressionParserBase
    {
        public TypedChainedExpressionParser() : base(@"TypedChained")
        {
        }

        protected override CrossCutting.Common.Results.Result<ExpressionFramework.Domain.Expression> DoParse(CrossCutting.Utilities.Parsers.FunctionParseResult functionParseResult, CrossCutting.Utilities.Parsers.Contracts.IFunctionParseResultEvaluator evaluator, CrossCutting.Utilities.Parsers.Contracts.IExpressionParser parser)
        {
            return ParseTypedExpression(typeof(TypedChainedExpression<>), 0, @"Expressions", functionParseResult, evaluator, parser);
        }

        protected override bool IsNameValid(string functionName)
        {
            return base.IsNameValid(functionName.WithoutGenerics());
        }
    }
    public class TypedConstantExpressionParser : ExpressionParserBase
    {
        public TypedConstantExpressionParser() : base(@"TypedConstant")
        {
        }

        protected override CrossCutting.Common.Results.Result<ExpressionFramework.Domain.Expression> DoParse(CrossCutting.Utilities.Parsers.FunctionParseResult functionParseResult, CrossCutting.Utilities.Parsers.Contracts.IFunctionParseResultEvaluator evaluator, CrossCutting.Utilities.Parsers.Contracts.IExpressionParser parser)
        {
            return ParseTypedExpression(typeof(TypedConstantExpression<>), 0, @"Value", functionParseResult, evaluator, parser);
        }

        protected override bool IsNameValid(string functionName)
        {
            return base.IsNameValid(functionName.WithoutGenerics());
        }
    }
    public class TypedConstantResultExpressionParser : ExpressionParserBase
    {
        public TypedConstantResultExpressionParser() : base(@"TypedConstantResult")
        {
        }

        protected override CrossCutting.Common.Results.Result<ExpressionFramework.Domain.Expression> DoParse(CrossCutting.Utilities.Parsers.FunctionParseResult functionParseResult, CrossCutting.Utilities.Parsers.Contracts.IFunctionParseResultEvaluator evaluator, CrossCutting.Utilities.Parsers.Contracts.IExpressionParser parser)
        {
            return ParseTypedExpression(typeof(TypedConstantResultExpression<>), 0, @"Value", functionParseResult, evaluator, parser);
        }

        protected override bool IsNameValid(string functionName)
        {
            return base.IsNameValid(functionName.WithoutGenerics());
        }
    }
    public class TypedContextExpressionParser : ExpressionParserBase
    {
        public TypedContextExpressionParser() : base(@"TypedContext")
        {
        }

        protected override CrossCutting.Common.Results.Result<ExpressionFramework.Domain.Expression> DoParse(CrossCutting.Utilities.Parsers.FunctionParseResult functionParseResult, CrossCutting.Utilities.Parsers.Contracts.IFunctionParseResultEvaluator evaluator, CrossCutting.Utilities.Parsers.Contracts.IExpressionParser parser)
        {
            var typeResult = functionParseResult.FunctionName.GetGenericTypeResult();
            if (!typeResult.IsSuccessful())
            {
                return Result.FromExistingResult<ExpressionFramework.Domain.Expression>(typeResult);
            }
            #pragma warning disable CS8620 // Argument cannot be used for parameter due to differences in the nullability of reference types.
            return Result.Success<ExpressionFramework.Domain.Expression>((ExpressionFramework.Domain.Expression)System.Activator.CreateInstance(typeof(ExpressionFramework.Domain.Expressions.TypedContextExpression<>).MakeGenericType(typeResult.Value!)));
            #pragma warning restore CS8620 // Argument cannot be used for parameter due to differences in the nullability of reference types.
        }

        protected override bool IsNameValid(string functionName)
        {
            return base.IsNameValid(functionName.WithoutGenerics());
        }
    }
    public class TypedDelegateExpressionParser : ExpressionParserBase
    {
        public TypedDelegateExpressionParser() : base(@"TypedDelegate")
        {
        }

        protected override CrossCutting.Common.Results.Result<ExpressionFramework.Domain.Expression> DoParse(CrossCutting.Utilities.Parsers.FunctionParseResult functionParseResult, CrossCutting.Utilities.Parsers.Contracts.IFunctionParseResultEvaluator evaluator, CrossCutting.Utilities.Parsers.Contracts.IExpressionParser parser)
        {
            return ParseTypedExpression(typeof(TypedDelegateExpression<>), 0, @"Value", functionParseResult, evaluator, parser);
        }

        protected override bool IsNameValid(string functionName)
        {
            return base.IsNameValid(functionName.WithoutGenerics());
        }
    }
    public class TypedDelegateResultExpressionParser : ExpressionParserBase
    {
        public TypedDelegateResultExpressionParser() : base(@"TypedDelegateResult")
        {
        }

        protected override CrossCutting.Common.Results.Result<ExpressionFramework.Domain.Expression> DoParse(CrossCutting.Utilities.Parsers.FunctionParseResult functionParseResult, CrossCutting.Utilities.Parsers.Contracts.IFunctionParseResultEvaluator evaluator, CrossCutting.Utilities.Parsers.Contracts.IExpressionParser parser)
        {
            return ParseTypedExpression(typeof(TypedDelegateResultExpression<>), 0, @"Value", functionParseResult, evaluator, parser);
        }

        protected override bool IsNameValid(string functionName)
        {
            return base.IsNameValid(functionName.WithoutGenerics());
        }
    }
    public class TypedFieldExpressionParser : ExpressionParserBase
    {
        public TypedFieldExpressionParser() : base(@"TypedField")
        {
        }

        protected override CrossCutting.Common.Results.Result<ExpressionFramework.Domain.Expression> DoParse(CrossCutting.Utilities.Parsers.FunctionParseResult functionParseResult, CrossCutting.Utilities.Parsers.Contracts.IFunctionParseResultEvaluator evaluator, CrossCutting.Utilities.Parsers.Contracts.IExpressionParser parser)
        {
            var typeResult = functionParseResult.FunctionName.GetGenericTypeResult();
            if (!typeResult.IsSuccessful())
            {
                return Result.FromExistingResult<ExpressionFramework.Domain.Expression>(typeResult);
            }
            #pragma warning disable CS8620 // Argument cannot be used for parameter due to differences in the nullability of reference types.
            return Result.Success<ExpressionFramework.Domain.Expression>((ExpressionFramework.Domain.Expression)System.Activator.CreateInstance(typeof(ExpressionFramework.Domain.Expressions.TypedFieldExpression<>).MakeGenericType(typeResult.Value!)));
            #pragma warning restore CS8620 // Argument cannot be used for parameter due to differences in the nullability of reference types.
        }

        protected override bool IsNameValid(string functionName)
        {
            return base.IsNameValid(functionName.WithoutGenerics());
        }
    }
    public class WhereExpressionParser : ExpressionParserBase
    {
        public WhereExpressionParser() : base(@"Where")
        {
        }

        protected override CrossCutting.Common.Results.Result<ExpressionFramework.Domain.Expression> DoParse(CrossCutting.Utilities.Parsers.FunctionParseResult functionParseResult, CrossCutting.Utilities.Parsers.Contracts.IFunctionParseResultEvaluator evaluator, CrossCutting.Utilities.Parsers.Contracts.IExpressionParser parser)
        {
            #pragma warning disable CS8620 // Argument cannot be used for parameter due to differences in the nullability of reference types.
            return Result.Success<ExpressionFramework.Domain.Expression>(new ExpressionFramework.Domain.Expressions.WhereExpression(
    functionParseResult.GetTypedExpressionsArgumentValueExpression(0, @"Expression", evaluator, parser),
    functionParseResult.GetArgumentBooleanValueExpression(1, @"PredicateExpression", evaluator, parser)));
            #pragma warning restore CS8620 // Argument cannot be used for parameter due to differences in the nullability of reference types.
        }
    }
    public class YearExpressionParser : ExpressionParserBase
    {
        public YearExpressionParser() : base(@"Year")
        {
        }

        protected override CrossCutting.Common.Results.Result<ExpressionFramework.Domain.Expression> DoParse(CrossCutting.Utilities.Parsers.FunctionParseResult functionParseResult, CrossCutting.Utilities.Parsers.Contracts.IFunctionParseResultEvaluator evaluator, CrossCutting.Utilities.Parsers.Contracts.IExpressionParser parser)
        {
            #pragma warning disable CS8620 // Argument cannot be used for parameter due to differences in the nullability of reference types.
            return Result.Success<ExpressionFramework.Domain.Expression>(new ExpressionFramework.Domain.Expressions.YearExpression(
    functionParseResult.GetArgumentDateTimeValueExpression(0, @"Expression", evaluator, parser)));
            #pragma warning restore CS8620 // Argument cannot be used for parameter due to differences in the nullability of reference types.
        }
    }
}
#nullable disable
