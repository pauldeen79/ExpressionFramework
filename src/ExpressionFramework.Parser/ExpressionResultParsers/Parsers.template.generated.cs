// ------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version: 9.0.1
//  
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
// ------------------------------------------------------------------------------
#nullable enable
namespace ExpressionFramework.Parser.ExpressionResultParsers
{
    [FunctionName(@"Aggregate")]
    [FunctionArgument(@"Expressions", typeof(System.Collections.IEnumerable))]
    [FunctionArgument(@"Aggregator", typeof(ExpressionFramework.Domain.Aggregator))]
    [FunctionArgument(@"FormatProviderExpression", typeof(System.IFormatProvider), false)]
    public class AggregateExpressionParser : ExpressionParserBase
    {
        protected override CrossCutting.Common.Results.Result<ExpressionFramework.Domain.Expression> DoParse(CrossCutting.Utilities.Parsers.FunctionCallContext context)
        {
            var aggregatorResult = context.GetArgumentExpressionResult<ExpressionFramework.Domain.Aggregator>(1, @"Aggregator");
            var error = new Result[]
            {
                aggregatorResult,
            }.FirstOrDefault(x => !x.IsSuccessful());
            if (error is not null)
            {
                return Result.FromExistingResult<ExpressionFramework.Domain.Expression>(error);
            }
            #pragma warning disable CS8620 // Argument cannot be used for parameter due to differences in the nullability of reference types.
            return Result.Success<ExpressionFramework.Domain.Expression>(new ExpressionFramework.Domain.Expressions.AggregateExpression(
                context.GetExpressionsArgumentValueResult(0, @"Expressions"),
                aggregatorResult.Value!,
                context.GetArgumentValueExpression<System.IFormatProvider>(2, @"FormatProviderExpression", default)));
            #pragma warning restore CS8620 // Argument cannot be used for parameter due to differences in the nullability of reference types.
        }
    }
    [FunctionName(@"All")]
    [FunctionArgument(@"Expression", typeof(System.Collections.IEnumerable))]
    [FunctionArgument(@"PredicateExpression", typeof(System.Boolean))]
    public class AllExpressionParser : ExpressionParserBase
    {
        protected override CrossCutting.Common.Results.Result<ExpressionFramework.Domain.Expression> DoParse(CrossCutting.Utilities.Parsers.FunctionCallContext context)
        {
            #pragma warning disable CS8620 // Argument cannot be used for parameter due to differences in the nullability of reference types.
            return Result.Success<ExpressionFramework.Domain.Expression>(new ExpressionFramework.Domain.Expressions.AllExpression(
                context.GetTypedExpressionsArgumentValueExpression(0, @"Expression"),
                context.GetArgumentBooleanValueExpression(1, @"PredicateExpression")));
            #pragma warning restore CS8620 // Argument cannot be used for parameter due to differences in the nullability of reference types.
        }
    }
    [FunctionName(@"And")]
    [FunctionArgument(@"FirstExpression", typeof(System.Boolean))]
    [FunctionArgument(@"SecondExpression", typeof(System.Boolean))]
    public class AndExpressionParser : ExpressionParserBase
    {
        protected override CrossCutting.Common.Results.Result<ExpressionFramework.Domain.Expression> DoParse(CrossCutting.Utilities.Parsers.FunctionCallContext context)
        {
            #pragma warning disable CS8620 // Argument cannot be used for parameter due to differences in the nullability of reference types.
            return Result.Success<ExpressionFramework.Domain.Expression>(new ExpressionFramework.Domain.Expressions.AndExpression(
                context.GetArgumentBooleanValueExpression(0, @"FirstExpression"),
                context.GetArgumentBooleanValueExpression(1, @"SecondExpression")));
            #pragma warning restore CS8620 // Argument cannot be used for parameter due to differences in the nullability of reference types.
        }
    }
    [FunctionName(@"Any")]
    [FunctionArgument(@"Expression", typeof(System.Collections.IEnumerable))]
    [FunctionArgument(@"PredicateExpression", typeof(System.Boolean), false)]
    public class AnyExpressionParser : ExpressionParserBase
    {
        protected override CrossCutting.Common.Results.Result<ExpressionFramework.Domain.Expression> DoParse(CrossCutting.Utilities.Parsers.FunctionCallContext context)
        {
            #pragma warning disable CS8620 // Argument cannot be used for parameter due to differences in the nullability of reference types.
            return Result.Success<ExpressionFramework.Domain.Expression>(new ExpressionFramework.Domain.Expressions.AnyExpression(
                context.GetTypedExpressionsArgumentValueExpression(0, @"Expression"),
                context.GetArgumentBooleanValueExpression(1, @"PredicateExpression", default)));
            #pragma warning restore CS8620 // Argument cannot be used for parameter due to differences in the nullability of reference types.
        }
    }
    [FunctionName(@"Cast")]
    [FunctionArgument(@"SourceExpression", typeof(object))]
    public class CastExpressionParser : ExpressionParserBase
    {
        protected override CrossCutting.Common.Results.Result<ExpressionFramework.Domain.Expression> DoParse(CrossCutting.Utilities.Parsers.FunctionCallContext context)
        {
            return ParseTypedExpression(typeof(CastExpression<>), 0, @"SourceExpression", context);
        }
    }
    [FunctionName(@"Chained")]
    [FunctionArgument(@"Expressions", typeof(System.Collections.IEnumerable))]
    public class ChainedExpressionParser : ExpressionParserBase
    {
        protected override CrossCutting.Common.Results.Result<ExpressionFramework.Domain.Expression> DoParse(CrossCutting.Utilities.Parsers.FunctionCallContext context)
        {
            #pragma warning disable CS8620 // Argument cannot be used for parameter due to differences in the nullability of reference types.
            return Result.Success<ExpressionFramework.Domain.Expression>(new ExpressionFramework.Domain.Expressions.ChainedExpression(
                context.GetExpressionsArgumentValueResult(0, @"Expressions")));
            #pragma warning restore CS8620 // Argument cannot be used for parameter due to differences in the nullability of reference types.
        }
    }
    [FunctionName(@"Compound")]
    [FunctionArgument(@"FirstExpression", typeof(object))]
    [FunctionArgument(@"SecondExpression", typeof(object))]
    [FunctionArgument(@"Aggregator", typeof(ExpressionFramework.Domain.Aggregator))]
    [FunctionArgument(@"FormatProviderExpression", typeof(System.IFormatProvider), false)]
    public class CompoundExpressionParser : ExpressionParserBase
    {
        protected override CrossCutting.Common.Results.Result<ExpressionFramework.Domain.Expression> DoParse(CrossCutting.Utilities.Parsers.FunctionCallContext context)
        {
            var aggregatorResult = context.GetArgumentExpressionResult<ExpressionFramework.Domain.Aggregator>(2, @"Aggregator");
            var error = new Result[]
            {
                aggregatorResult,
            }.FirstOrDefault(x => !x.IsSuccessful());
            if (error is not null)
            {
                return Result.FromExistingResult<ExpressionFramework.Domain.Expression>(error);
            }
            #pragma warning disable CS8620 // Argument cannot be used for parameter due to differences in the nullability of reference types.
            return Result.Success<ExpressionFramework.Domain.Expression>(new ExpressionFramework.Domain.Expressions.CompoundExpression(
                new TypedConstantResultExpression<System.Object>(context.GetArgumentValueResult(0, @"FirstExpression")),
                new TypedConstantResultExpression<System.Object>(context.GetArgumentValueResult(1, @"SecondExpression")),
                aggregatorResult.Value!,
                context.GetArgumentValueExpression<System.IFormatProvider>(3, @"FormatProviderExpression", default)));
            #pragma warning restore CS8620 // Argument cannot be used for parameter due to differences in the nullability of reference types.
        }
    }
    [FunctionName(@"Constant")]
    [FunctionArgument(@"Value", typeof(System.Object))]
    public class ConstantExpressionParser : ExpressionParserBase
    {
        protected override CrossCutting.Common.Results.Result<ExpressionFramework.Domain.Expression> DoParse(CrossCutting.Utilities.Parsers.FunctionCallContext context)
        {
            var valueResult = context.GetArgumentValueResult(0, @"Value", default);
            var error = new Result[]
            {
                valueResult,
            }.FirstOrDefault(x => !x.IsSuccessful());
            if (error is not null)
            {
                return Result.FromExistingResult<ExpressionFramework.Domain.Expression>(error);
            }
            #pragma warning disable CS8620 // Argument cannot be used for parameter due to differences in the nullability of reference types.
            return Result.Success<ExpressionFramework.Domain.Expression>(new ExpressionFramework.Domain.Expressions.ConstantExpression(
                valueResult.Value));
            #pragma warning restore CS8620 // Argument cannot be used for parameter due to differences in the nullability of reference types.
        }
    }
    [FunctionName(@"ConstantResult")]
    [FunctionArgument(@"Value", typeof(CrossCutting.Common.Results.Result))]
    public class ConstantResultExpressionParser : ExpressionParserBase
    {
        protected override CrossCutting.Common.Results.Result<ExpressionFramework.Domain.Expression> DoParse(CrossCutting.Utilities.Parsers.FunctionCallContext context)
        {
            var valueResult = context.GetArgumentExpressionResult<CrossCutting.Common.Results.Result>(0, @"Value");
            var error = new Result[]
            {
                valueResult,
            }.FirstOrDefault(x => !x.IsSuccessful());
            if (error is not null)
            {
                return Result.FromExistingResult<ExpressionFramework.Domain.Expression>(error);
            }
            #pragma warning disable CS8620 // Argument cannot be used for parameter due to differences in the nullability of reference types.
            return Result.Success<ExpressionFramework.Domain.Expression>(new ExpressionFramework.Domain.Expressions.ConstantResultExpression(
                valueResult.Value!));
            #pragma warning restore CS8620 // Argument cannot be used for parameter due to differences in the nullability of reference types.
        }
    }
    [FunctionName(@"Context")]
    public class ContextExpressionParser : ExpressionParserBase
    {
        protected override CrossCutting.Common.Results.Result<ExpressionFramework.Domain.Expression> DoParse(CrossCutting.Utilities.Parsers.FunctionCallContext context)
        {
            #pragma warning disable CS8620 // Argument cannot be used for parameter due to differences in the nullability of reference types.
            return Result.Success<ExpressionFramework.Domain.Expression>(new ExpressionFramework.Domain.Expressions.ContextExpression(
                ));
            #pragma warning restore CS8620 // Argument cannot be used for parameter due to differences in the nullability of reference types.
        }
    }
    [FunctionName(@"Count")]
    [FunctionArgument(@"Expression", typeof(System.Collections.IEnumerable))]
    [FunctionArgument(@"PredicateExpression", typeof(System.Boolean), false)]
    public class CountExpressionParser : ExpressionParserBase
    {
        protected override CrossCutting.Common.Results.Result<ExpressionFramework.Domain.Expression> DoParse(CrossCutting.Utilities.Parsers.FunctionCallContext context)
        {
            #pragma warning disable CS8620 // Argument cannot be used for parameter due to differences in the nullability of reference types.
            return Result.Success<ExpressionFramework.Domain.Expression>(new ExpressionFramework.Domain.Expressions.CountExpression(
                context.GetTypedExpressionsArgumentValueExpression(0, @"Expression"),
                context.GetArgumentBooleanValueExpression(1, @"PredicateExpression", default)));
            #pragma warning restore CS8620 // Argument cannot be used for parameter due to differences in the nullability of reference types.
        }
    }
    [FunctionName(@"Day")]
    [FunctionArgument(@"Expression", typeof(System.DateTime))]
    public class DayExpressionParser : ExpressionParserBase
    {
        protected override CrossCutting.Common.Results.Result<ExpressionFramework.Domain.Expression> DoParse(CrossCutting.Utilities.Parsers.FunctionCallContext context)
        {
            #pragma warning disable CS8620 // Argument cannot be used for parameter due to differences in the nullability of reference types.
            return Result.Success<ExpressionFramework.Domain.Expression>(new ExpressionFramework.Domain.Expressions.DayExpression(
                context.GetArgumentDateTimeValueExpression(0, @"Expression")));
            #pragma warning restore CS8620 // Argument cannot be used for parameter due to differences in the nullability of reference types.
        }
    }
    [FunctionName(@"Default")]
    public class DefaultExpressionParser : ExpressionParserBase
    {
        protected override CrossCutting.Common.Results.Result<ExpressionFramework.Domain.Expression> DoParse(CrossCutting.Utilities.Parsers.FunctionCallContext context)
        {
            var typeResult = context.FunctionCall.Name.GetGenericTypeResult();
            if (!typeResult.IsSuccessful())
            {
                return Result.FromExistingResult<ExpressionFramework.Domain.Expression>(typeResult);
            }
            #pragma warning disable CS8620 // Argument cannot be used for parameter due to differences in the nullability of reference types.
            return Result.Success<ExpressionFramework.Domain.Expression>((ExpressionFramework.Domain.Expression)System.Activator.CreateInstance(typeof(ExpressionFramework.Domain.Expressions.DefaultExpression<>).MakeGenericType(typeResult.Value!)));
            #pragma warning restore CS8620 // Argument cannot be used for parameter due to differences in the nullability of reference types.
        }
    }
    [FunctionName(@"Delegate")]
    [FunctionArgument(@"Value", typeof(System.Func<System.Object?>))]
    public class DelegateExpressionParser : ExpressionParserBase
    {
        protected override CrossCutting.Common.Results.Result<ExpressionFramework.Domain.Expression> DoParse(CrossCutting.Utilities.Parsers.FunctionCallContext context)
        {
            var valueResult = context.GetArgumentExpressionResult<System.Func<System.Object?,System.Object?>>(0, @"Value");
            var error = new Result[]
            {
                valueResult,
            }.FirstOrDefault(x => !x.IsSuccessful());
            if (error is not null)
            {
                return Result.FromExistingResult<ExpressionFramework.Domain.Expression>(error);
            }
            #pragma warning disable CS8620 // Argument cannot be used for parameter due to differences in the nullability of reference types.
            return Result.Success<ExpressionFramework.Domain.Expression>(new ExpressionFramework.Domain.Expressions.DelegateExpression(
                valueResult.Value!));
            #pragma warning restore CS8620 // Argument cannot be used for parameter due to differences in the nullability of reference types.
        }
    }
    [FunctionName(@"DelegateResult")]
    [FunctionArgument(@"Result", typeof(System.Func<System.Object?>))]
    public class DelegateResultExpressionParser : ExpressionParserBase
    {
        protected override CrossCutting.Common.Results.Result<ExpressionFramework.Domain.Expression> DoParse(CrossCutting.Utilities.Parsers.FunctionCallContext context)
        {
            var resultResult = context.GetArgumentExpressionResult<System.Func<System.Object?,CrossCutting.Common.Results.Result<System.Object?>>>(0, @"Result");
            var error = new Result[]
            {
                resultResult,
            }.FirstOrDefault(x => !x.IsSuccessful());
            if (error is not null)
            {
                return Result.FromExistingResult<ExpressionFramework.Domain.Expression>(error);
            }
            #pragma warning disable CS8620 // Argument cannot be used for parameter due to differences in the nullability of reference types.
            return Result.Success<ExpressionFramework.Domain.Expression>(new ExpressionFramework.Domain.Expressions.DelegateResultExpression(
                resultResult.Value!));
            #pragma warning restore CS8620 // Argument cannot be used for parameter due to differences in the nullability of reference types.
        }
    }
    [FunctionName(@"ElementAt")]
    [FunctionArgument(@"Expression", typeof(System.Collections.IEnumerable))]
    [FunctionArgument(@"IndexExpression", typeof(System.Int32))]
    public class ElementAtExpressionParser : ExpressionParserBase
    {
        protected override CrossCutting.Common.Results.Result<ExpressionFramework.Domain.Expression> DoParse(CrossCutting.Utilities.Parsers.FunctionCallContext context)
        {
            #pragma warning disable CS8620 // Argument cannot be used for parameter due to differences in the nullability of reference types.
            return Result.Success<ExpressionFramework.Domain.Expression>(new ExpressionFramework.Domain.Expressions.ElementAtExpression(
                context.GetTypedExpressionsArgumentValueExpression(0, @"Expression"),
                context.GetArgumentInt32ValueExpression(1, @"IndexExpression")));
            #pragma warning restore CS8620 // Argument cannot be used for parameter due to differences in the nullability of reference types.
        }
    }
    [FunctionName(@"ElementAtOrDefault")]
    [FunctionArgument(@"Expression", typeof(System.Collections.IEnumerable))]
    [FunctionArgument(@"IndexExpression", typeof(System.Int32))]
    [FunctionArgument(@"DefaultExpression", typeof(object))]
    public class ElementAtOrDefaultExpressionParser : ExpressionParserBase
    {
        protected override CrossCutting.Common.Results.Result<ExpressionFramework.Domain.Expression> DoParse(CrossCutting.Utilities.Parsers.FunctionCallContext context)
        {
            #pragma warning disable CS8620 // Argument cannot be used for parameter due to differences in the nullability of reference types.
            return Result.Success<ExpressionFramework.Domain.Expression>(new ExpressionFramework.Domain.Expressions.ElementAtOrDefaultExpression(
                context.GetTypedExpressionsArgumentValueExpression(0, @"Expression"),
                context.GetArgumentInt32ValueExpression(1, @"IndexExpression"),
                new TypedConstantResultExpression<System.Object?>(context.GetArgumentValueResult(2, @"DefaultExpression", default))));
            #pragma warning restore CS8620 // Argument cannot be used for parameter due to differences in the nullability of reference types.
        }
    }
    [FunctionName(@"Empty")]
    public class EmptyExpressionParser : ExpressionParserBase
    {
        protected override CrossCutting.Common.Results.Result<ExpressionFramework.Domain.Expression> DoParse(CrossCutting.Utilities.Parsers.FunctionCallContext context)
        {
            #pragma warning disable CS8620 // Argument cannot be used for parameter due to differences in the nullability of reference types.
            return Result.Success<ExpressionFramework.Domain.Expression>(new ExpressionFramework.Domain.Expressions.EmptyExpression(
                ));
            #pragma warning restore CS8620 // Argument cannot be used for parameter due to differences in the nullability of reference types.
        }
    }
    [FunctionName(@"Equals")]
    [FunctionArgument(@"FirstExpression", typeof(object))]
    [FunctionArgument(@"SecondExpression", typeof(object))]
    public class EqualsExpressionParser : ExpressionParserBase
    {
        protected override CrossCutting.Common.Results.Result<ExpressionFramework.Domain.Expression> DoParse(CrossCutting.Utilities.Parsers.FunctionCallContext context)
        {
            #pragma warning disable CS8620 // Argument cannot be used for parameter due to differences in the nullability of reference types.
            return Result.Success<ExpressionFramework.Domain.Expression>(new ExpressionFramework.Domain.Expressions.EqualsExpression(
                new TypedConstantResultExpression<System.Object>(context.GetArgumentValueResult(0, @"FirstExpression")),
                new TypedConstantResultExpression<System.Object>(context.GetArgumentValueResult(1, @"SecondExpression"))));
            #pragma warning restore CS8620 // Argument cannot be used for parameter due to differences in the nullability of reference types.
        }
    }
    [FunctionName(@"Error")]
    [FunctionArgument(@"ErrorMessageExpression", typeof(System.String))]
    public class ErrorExpressionParser : ExpressionParserBase
    {
        protected override CrossCutting.Common.Results.Result<ExpressionFramework.Domain.Expression> DoParse(CrossCutting.Utilities.Parsers.FunctionCallContext context)
        {
            #pragma warning disable CS8620 // Argument cannot be used for parameter due to differences in the nullability of reference types.
            return Result.Success<ExpressionFramework.Domain.Expression>(new ExpressionFramework.Domain.Expressions.ErrorExpression(
                context.GetArgumentStringValueExpression(0, @"ErrorMessageExpression")));
            #pragma warning restore CS8620 // Argument cannot be used for parameter due to differences in the nullability of reference types.
        }
    }
    [FunctionName(@"Evaluatable")]
    [FunctionArgument(@"Condition", typeof(ExpressionFramework.Domain.Evaluatable))]
    [FunctionArgument(@"Expression", typeof(object))]
    public class EvaluatableExpressionParser : ExpressionParserBase
    {
        protected override CrossCutting.Common.Results.Result<ExpressionFramework.Domain.Expression> DoParse(CrossCutting.Utilities.Parsers.FunctionCallContext context)
        {
            var conditionResult = context.GetArgumentExpressionResult<ExpressionFramework.Domain.Evaluatable>(0, @"Condition");
            var error = new Result[]
            {
                conditionResult,
            }.FirstOrDefault(x => !x.IsSuccessful());
            if (error is not null)
            {
                return Result.FromExistingResult<ExpressionFramework.Domain.Expression>(error);
            }
            #pragma warning disable CS8620 // Argument cannot be used for parameter due to differences in the nullability of reference types.
            return Result.Success<ExpressionFramework.Domain.Expression>(new ExpressionFramework.Domain.Expressions.EvaluatableExpression(
                conditionResult.Value!,
                new TypedConstantResultExpression<System.Object>(context.GetArgumentValueResult(1, @"Expression"))));
            #pragma warning restore CS8620 // Argument cannot be used for parameter due to differences in the nullability of reference types.
        }
    }
    [FunctionName(@"False")]
    public class FalseExpressionParser : ExpressionParserBase
    {
        protected override CrossCutting.Common.Results.Result<ExpressionFramework.Domain.Expression> DoParse(CrossCutting.Utilities.Parsers.FunctionCallContext context)
        {
            #pragma warning disable CS8620 // Argument cannot be used for parameter due to differences in the nullability of reference types.
            return Result.Success<ExpressionFramework.Domain.Expression>(new ExpressionFramework.Domain.Expressions.FalseExpression(
                ));
            #pragma warning restore CS8620 // Argument cannot be used for parameter due to differences in the nullability of reference types.
        }
    }
    [FunctionName(@"Field")]
    [FunctionArgument(@"Expression", typeof(object))]
    [FunctionArgument(@"FieldNameExpression", typeof(System.String))]
    public class FieldExpressionParser : ExpressionParserBase
    {
        protected override CrossCutting.Common.Results.Result<ExpressionFramework.Domain.Expression> DoParse(CrossCutting.Utilities.Parsers.FunctionCallContext context)
        {
            #pragma warning disable CS8620 // Argument cannot be used for parameter due to differences in the nullability of reference types.
            return Result.Success<ExpressionFramework.Domain.Expression>(new ExpressionFramework.Domain.Expressions.FieldExpression(
                new TypedConstantResultExpression<System.Object>(context.GetArgumentValueResult(0, @"Expression")),
                context.GetArgumentStringValueExpression(1, @"FieldNameExpression")));
            #pragma warning restore CS8620 // Argument cannot be used for parameter due to differences in the nullability of reference types.
        }
    }
    [FunctionName(@"First")]
    [FunctionArgument(@"Expression", typeof(System.Collections.IEnumerable))]
    [FunctionArgument(@"PredicateExpression", typeof(System.Boolean), false)]
    public class FirstExpressionParser : ExpressionParserBase
    {
        protected override CrossCutting.Common.Results.Result<ExpressionFramework.Domain.Expression> DoParse(CrossCutting.Utilities.Parsers.FunctionCallContext context)
        {
            #pragma warning disable CS8620 // Argument cannot be used for parameter due to differences in the nullability of reference types.
            return Result.Success<ExpressionFramework.Domain.Expression>(new ExpressionFramework.Domain.Expressions.FirstExpression(
                context.GetTypedExpressionsArgumentValueExpression(0, @"Expression"),
                context.GetArgumentBooleanValueExpression(1, @"PredicateExpression", default)));
            #pragma warning restore CS8620 // Argument cannot be used for parameter due to differences in the nullability of reference types.
        }
    }
    [FunctionName(@"FirstOrDefault")]
    [FunctionArgument(@"Expression", typeof(System.Collections.IEnumerable))]
    [FunctionArgument(@"PredicateExpression", typeof(System.Boolean))]
    [FunctionArgument(@"DefaultExpression", typeof(object))]
    public class FirstOrDefaultExpressionParser : ExpressionParserBase
    {
        protected override CrossCutting.Common.Results.Result<ExpressionFramework.Domain.Expression> DoParse(CrossCutting.Utilities.Parsers.FunctionCallContext context)
        {
            #pragma warning disable CS8620 // Argument cannot be used for parameter due to differences in the nullability of reference types.
            return Result.Success<ExpressionFramework.Domain.Expression>(new ExpressionFramework.Domain.Expressions.FirstOrDefaultExpression(
                context.GetTypedExpressionsArgumentValueExpression(0, @"Expression"),
                context.GetArgumentBooleanValueExpression(1, @"PredicateExpression", default),
                new TypedConstantResultExpression<System.Object?>(context.GetArgumentValueResult(2, @"DefaultExpression", default))));
            #pragma warning restore CS8620 // Argument cannot be used for parameter due to differences in the nullability of reference types.
        }
    }
    [FunctionName(@"GroupBy")]
    [FunctionArgument(@"Expression", typeof(System.Collections.IEnumerable))]
    [FunctionArgument(@"KeySelectorExpression", typeof(object))]
    public class GroupByExpressionParser : ExpressionParserBase
    {
        protected override CrossCutting.Common.Results.Result<ExpressionFramework.Domain.Expression> DoParse(CrossCutting.Utilities.Parsers.FunctionCallContext context)
        {
            #pragma warning disable CS8620 // Argument cannot be used for parameter due to differences in the nullability of reference types.
            return Result.Success<ExpressionFramework.Domain.Expression>(new ExpressionFramework.Domain.Expressions.GroupByExpression(
                context.GetTypedExpressionsArgumentValueExpression(0, @"Expression"),
                new TypedConstantResultExpression<System.Object>(context.GetArgumentValueResult(1, @"KeySelectorExpression"))));
            #pragma warning restore CS8620 // Argument cannot be used for parameter due to differences in the nullability of reference types.
        }
    }
    [FunctionName(@"If")]
    [FunctionArgument(@"Condition", typeof(ExpressionFramework.Domain.Evaluatable))]
    [FunctionArgument(@"ResultExpression", typeof(object))]
    [FunctionArgument(@"DefaultExpression", typeof(object))]
    public class IfExpressionParser : ExpressionParserBase
    {
        protected override CrossCutting.Common.Results.Result<ExpressionFramework.Domain.Expression> DoParse(CrossCutting.Utilities.Parsers.FunctionCallContext context)
        {
            var conditionResult = context.GetArgumentExpressionResult<ExpressionFramework.Domain.Evaluatable>(0, @"Condition");
            var error = new Result[]
            {
                conditionResult,
            }.FirstOrDefault(x => !x.IsSuccessful());
            if (error is not null)
            {
                return Result.FromExistingResult<ExpressionFramework.Domain.Expression>(error);
            }
            #pragma warning disable CS8620 // Argument cannot be used for parameter due to differences in the nullability of reference types.
            return Result.Success<ExpressionFramework.Domain.Expression>(new ExpressionFramework.Domain.Expressions.IfExpression(
                conditionResult.Value!,
                new TypedConstantResultExpression<System.Object>(context.GetArgumentValueResult(1, @"ResultExpression")),
                new TypedConstantResultExpression<System.Object?>(context.GetArgumentValueResult(2, @"DefaultExpression", default))));
            #pragma warning restore CS8620 // Argument cannot be used for parameter due to differences in the nullability of reference types.
        }
    }
    [FunctionName(@"Invalid")]
    [FunctionArgument(@"ErrorMessageExpression", typeof(System.String))]
    [FunctionArgument(@"ValidationErrorExpressions", typeof(System.Collections.IEnumerable))]
    public class InvalidExpressionParser : ExpressionParserBase
    {
        protected override CrossCutting.Common.Results.Result<ExpressionFramework.Domain.Expression> DoParse(CrossCutting.Utilities.Parsers.FunctionCallContext context)
        {
            var validationErrorExpressionsResult = context.GetArgumentExpressionResult<System.Collections.Generic.IEnumerable<ExpressionFramework.Domain.Contracts.ITypedExpression<CrossCutting.Common.Results.ValidationError>>>(1, @"ValidationErrorExpressions");
            var error = new Result[]
            {
                validationErrorExpressionsResult,
            }.FirstOrDefault(x => !x.IsSuccessful());
            if (error is not null)
            {
                return Result.FromExistingResult<ExpressionFramework.Domain.Expression>(error);
            }
            #pragma warning disable CS8620 // Argument cannot be used for parameter due to differences in the nullability of reference types.
            return Result.Success<ExpressionFramework.Domain.Expression>(new ExpressionFramework.Domain.Expressions.InvalidExpression(
                context.GetArgumentStringValueExpression(0, @"ErrorMessageExpression"),
                validationErrorExpressionsResult.Value!));
            #pragma warning restore CS8620 // Argument cannot be used for parameter due to differences in the nullability of reference types.
        }
    }
    [FunctionName(@"Last")]
    [FunctionArgument(@"Expression", typeof(System.Collections.IEnumerable))]
    [FunctionArgument(@"PredicateExpression", typeof(System.Boolean), false)]
    public class LastExpressionParser : ExpressionParserBase
    {
        protected override CrossCutting.Common.Results.Result<ExpressionFramework.Domain.Expression> DoParse(CrossCutting.Utilities.Parsers.FunctionCallContext context)
        {
            #pragma warning disable CS8620 // Argument cannot be used for parameter due to differences in the nullability of reference types.
            return Result.Success<ExpressionFramework.Domain.Expression>(new ExpressionFramework.Domain.Expressions.LastExpression(
                context.GetTypedExpressionsArgumentValueExpression(0, @"Expression"),
                context.GetArgumentBooleanValueExpression(1, @"PredicateExpression", default)));
            #pragma warning restore CS8620 // Argument cannot be used for parameter due to differences in the nullability of reference types.
        }
    }
    [FunctionName(@"LastOrDefault")]
    [FunctionArgument(@"Expression", typeof(System.Collections.IEnumerable))]
    [FunctionArgument(@"PredicateExpression", typeof(System.Boolean))]
    [FunctionArgument(@"DefaultExpression", typeof(object))]
    public class LastOrDefaultExpressionParser : ExpressionParserBase
    {
        protected override CrossCutting.Common.Results.Result<ExpressionFramework.Domain.Expression> DoParse(CrossCutting.Utilities.Parsers.FunctionCallContext context)
        {
            #pragma warning disable CS8620 // Argument cannot be used for parameter due to differences in the nullability of reference types.
            return Result.Success<ExpressionFramework.Domain.Expression>(new ExpressionFramework.Domain.Expressions.LastOrDefaultExpression(
                context.GetTypedExpressionsArgumentValueExpression(0, @"Expression"),
                context.GetArgumentBooleanValueExpression(1, @"PredicateExpression", default),
                new TypedConstantResultExpression<System.Object?>(context.GetArgumentValueResult(2, @"DefaultExpression", default))));
            #pragma warning restore CS8620 // Argument cannot be used for parameter due to differences in the nullability of reference types.
        }
    }
    [FunctionName(@"Left")]
    [FunctionArgument(@"Expression", typeof(System.String))]
    [FunctionArgument(@"LengthExpression", typeof(System.Int32))]
    public class LeftExpressionParser : ExpressionParserBase
    {
        protected override CrossCutting.Common.Results.Result<ExpressionFramework.Domain.Expression> DoParse(CrossCutting.Utilities.Parsers.FunctionCallContext context)
        {
            #pragma warning disable CS8620 // Argument cannot be used for parameter due to differences in the nullability of reference types.
            return Result.Success<ExpressionFramework.Domain.Expression>(new ExpressionFramework.Domain.Expressions.LeftExpression(
                context.GetArgumentStringValueExpression(0, @"Expression"),
                context.GetArgumentInt32ValueExpression(1, @"LengthExpression")));
            #pragma warning restore CS8620 // Argument cannot be used for parameter due to differences in the nullability of reference types.
        }
    }
    [FunctionName(@"Max")]
    [FunctionArgument(@"Expression", typeof(System.Collections.IEnumerable))]
    [FunctionArgument(@"SelectorExpression", typeof(object))]
    public class MaxExpressionParser : ExpressionParserBase
    {
        protected override CrossCutting.Common.Results.Result<ExpressionFramework.Domain.Expression> DoParse(CrossCutting.Utilities.Parsers.FunctionCallContext context)
        {
            #pragma warning disable CS8620 // Argument cannot be used for parameter due to differences in the nullability of reference types.
            return Result.Success<ExpressionFramework.Domain.Expression>(new ExpressionFramework.Domain.Expressions.MaxExpression(
                context.GetTypedExpressionsArgumentValueExpression(0, @"Expression"),
                new TypedConstantResultExpression<System.Object?>(context.GetArgumentValueResult(1, @"SelectorExpression", default))));
            #pragma warning restore CS8620 // Argument cannot be used for parameter due to differences in the nullability of reference types.
        }
    }
    [FunctionName(@"Min")]
    [FunctionArgument(@"Expression", typeof(System.Collections.IEnumerable))]
    [FunctionArgument(@"SelectorExpression", typeof(object))]
    public class MinExpressionParser : ExpressionParserBase
    {
        protected override CrossCutting.Common.Results.Result<ExpressionFramework.Domain.Expression> DoParse(CrossCutting.Utilities.Parsers.FunctionCallContext context)
        {
            #pragma warning disable CS8620 // Argument cannot be used for parameter due to differences in the nullability of reference types.
            return Result.Success<ExpressionFramework.Domain.Expression>(new ExpressionFramework.Domain.Expressions.MinExpression(
                context.GetTypedExpressionsArgumentValueExpression(0, @"Expression"),
                new TypedConstantResultExpression<System.Object?>(context.GetArgumentValueResult(1, @"SelectorExpression", default))));
            #pragma warning restore CS8620 // Argument cannot be used for parameter due to differences in the nullability of reference types.
        }
    }
    [FunctionName(@"Month")]
    [FunctionArgument(@"Expression", typeof(System.DateTime))]
    public class MonthExpressionParser : ExpressionParserBase
    {
        protected override CrossCutting.Common.Results.Result<ExpressionFramework.Domain.Expression> DoParse(CrossCutting.Utilities.Parsers.FunctionCallContext context)
        {
            #pragma warning disable CS8620 // Argument cannot be used for parameter due to differences in the nullability of reference types.
            return Result.Success<ExpressionFramework.Domain.Expression>(new ExpressionFramework.Domain.Expressions.MonthExpression(
                context.GetArgumentDateTimeValueExpression(0, @"Expression")));
            #pragma warning restore CS8620 // Argument cannot be used for parameter due to differences in the nullability of reference types.
        }
    }
    [FunctionName(@"NotEquals")]
    [FunctionArgument(@"FirstExpression", typeof(object))]
    [FunctionArgument(@"SecondExpression", typeof(object))]
    public class NotEqualsExpressionParser : ExpressionParserBase
    {
        protected override CrossCutting.Common.Results.Result<ExpressionFramework.Domain.Expression> DoParse(CrossCutting.Utilities.Parsers.FunctionCallContext context)
        {
            #pragma warning disable CS8620 // Argument cannot be used for parameter due to differences in the nullability of reference types.
            return Result.Success<ExpressionFramework.Domain.Expression>(new ExpressionFramework.Domain.Expressions.NotEqualsExpression(
                new TypedConstantResultExpression<System.Object>(context.GetArgumentValueResult(0, @"FirstExpression")),
                new TypedConstantResultExpression<System.Object>(context.GetArgumentValueResult(1, @"SecondExpression"))));
            #pragma warning restore CS8620 // Argument cannot be used for parameter due to differences in the nullability of reference types.
        }
    }
    [FunctionName(@"Not")]
    [FunctionArgument(@"Expression", typeof(System.Boolean))]
    public class NotExpressionParser : ExpressionParserBase
    {
        protected override CrossCutting.Common.Results.Result<ExpressionFramework.Domain.Expression> DoParse(CrossCutting.Utilities.Parsers.FunctionCallContext context)
        {
            #pragma warning disable CS8620 // Argument cannot be used for parameter due to differences in the nullability of reference types.
            return Result.Success<ExpressionFramework.Domain.Expression>(new ExpressionFramework.Domain.Expressions.NotExpression(
                context.GetArgumentBooleanValueExpression(0, @"Expression")));
            #pragma warning restore CS8620 // Argument cannot be used for parameter due to differences in the nullability of reference types.
        }
    }
    [FunctionName(@"Now")]
    [FunctionArgument(@"DateTimeProvider", typeof(CrossCutting.Common.Abstractions.IDateTimeProvider))]
    public class NowExpressionParser : ExpressionParserBase
    {
        protected override CrossCutting.Common.Results.Result<ExpressionFramework.Domain.Expression> DoParse(CrossCutting.Utilities.Parsers.FunctionCallContext context)
        {
            var dateTimeProviderResult = context.GetArgumentExpressionResult<CrossCutting.Common.Abstractions.IDateTimeProvider>(0, @"DateTimeProvider", default);
            var error = new Result[]
            {
                dateTimeProviderResult,
            }.FirstOrDefault(x => !x.IsSuccessful());
            if (error is not null)
            {
                return Result.FromExistingResult<ExpressionFramework.Domain.Expression>(error);
            }
            #pragma warning disable CS8620 // Argument cannot be used for parameter due to differences in the nullability of reference types.
            return Result.Success<ExpressionFramework.Domain.Expression>(new ExpressionFramework.Domain.Expressions.NowExpression(
                dateTimeProviderResult.Value));
            #pragma warning restore CS8620 // Argument cannot be used for parameter due to differences in the nullability of reference types.
        }
    }
    [FunctionName(@"OfType")]
    [FunctionArgument(@"Expression", typeof(System.Collections.IEnumerable))]
    [FunctionArgument(@"TypeExpression", typeof(System.Type))]
    public class OfTypeExpressionParser : ExpressionParserBase
    {
        protected override CrossCutting.Common.Results.Result<ExpressionFramework.Domain.Expression> DoParse(CrossCutting.Utilities.Parsers.FunctionCallContext context)
        {
            #pragma warning disable CS8620 // Argument cannot be used for parameter due to differences in the nullability of reference types.
            return Result.Success<ExpressionFramework.Domain.Expression>(new ExpressionFramework.Domain.Expressions.OfTypeExpression(
                context.GetTypedExpressionsArgumentValueExpression(0, @"Expression"),
                context.GetArgumentValueExpression<System.Type>(1, @"TypeExpression")));
            #pragma warning restore CS8620 // Argument cannot be used for parameter due to differences in the nullability of reference types.
        }
    }
    [FunctionName(@"Operator")]
    [FunctionArgument(@"LeftExpression", typeof(object))]
    [FunctionArgument(@"RightExpression", typeof(object))]
    [FunctionArgument(@"Operator", typeof(ExpressionFramework.Domain.Operator))]
    public class OperatorExpressionParser : ExpressionParserBase
    {
        protected override CrossCutting.Common.Results.Result<ExpressionFramework.Domain.Expression> DoParse(CrossCutting.Utilities.Parsers.FunctionCallContext context)
        {
            var operatorResult = context.GetArgumentExpressionResult<ExpressionFramework.Domain.Operator>(2, @"Operator");
            var error = new Result[]
            {
                operatorResult,
            }.FirstOrDefault(x => !x.IsSuccessful());
            if (error is not null)
            {
                return Result.FromExistingResult<ExpressionFramework.Domain.Expression>(error);
            }
            #pragma warning disable CS8620 // Argument cannot be used for parameter due to differences in the nullability of reference types.
            return Result.Success<ExpressionFramework.Domain.Expression>(new ExpressionFramework.Domain.Expressions.OperatorExpression(
                new TypedConstantResultExpression<System.Object>(context.GetArgumentValueResult(0, @"LeftExpression")),
                new TypedConstantResultExpression<System.Object>(context.GetArgumentValueResult(1, @"RightExpression")),
                operatorResult.Value!));
            #pragma warning restore CS8620 // Argument cannot be used for parameter due to differences in the nullability of reference types.
        }
    }
    [FunctionName(@"OrderBy")]
    [FunctionArgument(@"Expression", typeof(System.Collections.IEnumerable))]
    [FunctionArgument(@"SortOrderExpressions", typeof(System.Collections.IEnumerable))]
    public class OrderByExpressionParser : ExpressionParserBase
    {
        protected override CrossCutting.Common.Results.Result<ExpressionFramework.Domain.Expression> DoParse(CrossCutting.Utilities.Parsers.FunctionCallContext context)
        {
            var sortOrderExpressionsResult = context.GetArgumentExpressionResult<System.Collections.Generic.IEnumerable<ExpressionFramework.Domain.Contracts.ITypedExpression<ExpressionFramework.Domain.SortOrder>>>(1, @"SortOrderExpressions");
            var error = new Result[]
            {
                sortOrderExpressionsResult,
            }.FirstOrDefault(x => !x.IsSuccessful());
            if (error is not null)
            {
                return Result.FromExistingResult<ExpressionFramework.Domain.Expression>(error);
            }
            #pragma warning disable CS8620 // Argument cannot be used for parameter due to differences in the nullability of reference types.
            return Result.Success<ExpressionFramework.Domain.Expression>(new ExpressionFramework.Domain.Expressions.OrderByExpression(
                context.GetTypedExpressionsArgumentValueExpression(0, @"Expression"),
                sortOrderExpressionsResult.Value!));
            #pragma warning restore CS8620 // Argument cannot be used for parameter due to differences in the nullability of reference types.
        }
    }
    [FunctionName(@"Or")]
    [FunctionArgument(@"FirstExpression", typeof(System.Boolean))]
    [FunctionArgument(@"SecondExpression", typeof(System.Boolean))]
    public class OrExpressionParser : ExpressionParserBase
    {
        protected override CrossCutting.Common.Results.Result<ExpressionFramework.Domain.Expression> DoParse(CrossCutting.Utilities.Parsers.FunctionCallContext context)
        {
            #pragma warning disable CS8620 // Argument cannot be used for parameter due to differences in the nullability of reference types.
            return Result.Success<ExpressionFramework.Domain.Expression>(new ExpressionFramework.Domain.Expressions.OrExpression(
                context.GetArgumentBooleanValueExpression(0, @"FirstExpression"),
                context.GetArgumentBooleanValueExpression(1, @"SecondExpression")));
            #pragma warning restore CS8620 // Argument cannot be used for parameter due to differences in the nullability of reference types.
        }
    }
    [FunctionName(@"Right")]
    [FunctionArgument(@"Expression", typeof(System.String))]
    [FunctionArgument(@"LengthExpression", typeof(System.Int32))]
    public class RightExpressionParser : ExpressionParserBase
    {
        protected override CrossCutting.Common.Results.Result<ExpressionFramework.Domain.Expression> DoParse(CrossCutting.Utilities.Parsers.FunctionCallContext context)
        {
            #pragma warning disable CS8620 // Argument cannot be used for parameter due to differences in the nullability of reference types.
            return Result.Success<ExpressionFramework.Domain.Expression>(new ExpressionFramework.Domain.Expressions.RightExpression(
                context.GetArgumentStringValueExpression(0, @"Expression"),
                context.GetArgumentInt32ValueExpression(1, @"LengthExpression")));
            #pragma warning restore CS8620 // Argument cannot be used for parameter due to differences in the nullability of reference types.
        }
    }
    [FunctionName(@"Select")]
    [FunctionArgument(@"Expression", typeof(System.Collections.IEnumerable))]
    [FunctionArgument(@"SelectorExpression", typeof(object))]
    public class SelectExpressionParser : ExpressionParserBase
    {
        protected override CrossCutting.Common.Results.Result<ExpressionFramework.Domain.Expression> DoParse(CrossCutting.Utilities.Parsers.FunctionCallContext context)
        {
            #pragma warning disable CS8620 // Argument cannot be used for parameter due to differences in the nullability of reference types.
            return Result.Success<ExpressionFramework.Domain.Expression>(new ExpressionFramework.Domain.Expressions.SelectExpression(
                context.GetTypedExpressionsArgumentValueExpression(0, @"Expression"),
                new TypedConstantResultExpression<System.Object>(context.GetArgumentValueResult(1, @"SelectorExpression"))));
            #pragma warning restore CS8620 // Argument cannot be used for parameter due to differences in the nullability of reference types.
        }
    }
    [FunctionName(@"Sequence")]
    [FunctionArgument(@"Expressions", typeof(System.Collections.IEnumerable))]
    public class SequenceExpressionParser : ExpressionParserBase
    {
        protected override CrossCutting.Common.Results.Result<ExpressionFramework.Domain.Expression> DoParse(CrossCutting.Utilities.Parsers.FunctionCallContext context)
        {
            #pragma warning disable CS8620 // Argument cannot be used for parameter due to differences in the nullability of reference types.
            return Result.Success<ExpressionFramework.Domain.Expression>(new ExpressionFramework.Domain.Expressions.SequenceExpression(
                context.GetExpressionsArgumentValueResult(0, @"Expressions")));
            #pragma warning restore CS8620 // Argument cannot be used for parameter due to differences in the nullability of reference types.
        }
    }
    [FunctionName(@"Single")]
    [FunctionArgument(@"Expression", typeof(System.Collections.IEnumerable))]
    [FunctionArgument(@"PredicateExpression", typeof(System.Boolean), false)]
    public class SingleExpressionParser : ExpressionParserBase
    {
        protected override CrossCutting.Common.Results.Result<ExpressionFramework.Domain.Expression> DoParse(CrossCutting.Utilities.Parsers.FunctionCallContext context)
        {
            #pragma warning disable CS8620 // Argument cannot be used for parameter due to differences in the nullability of reference types.
            return Result.Success<ExpressionFramework.Domain.Expression>(new ExpressionFramework.Domain.Expressions.SingleExpression(
                context.GetTypedExpressionsArgumentValueExpression(0, @"Expression"),
                context.GetArgumentBooleanValueExpression(1, @"PredicateExpression", default)));
            #pragma warning restore CS8620 // Argument cannot be used for parameter due to differences in the nullability of reference types.
        }
    }
    [FunctionName(@"SingleOrDefault")]
    [FunctionArgument(@"Expression", typeof(System.Collections.IEnumerable))]
    [FunctionArgument(@"PredicateExpression", typeof(System.Boolean))]
    [FunctionArgument(@"DefaultExpression", typeof(object))]
    public class SingleOrDefaultExpressionParser : ExpressionParserBase
    {
        protected override CrossCutting.Common.Results.Result<ExpressionFramework.Domain.Expression> DoParse(CrossCutting.Utilities.Parsers.FunctionCallContext context)
        {
            #pragma warning disable CS8620 // Argument cannot be used for parameter due to differences in the nullability of reference types.
            return Result.Success<ExpressionFramework.Domain.Expression>(new ExpressionFramework.Domain.Expressions.SingleOrDefaultExpression(
                context.GetTypedExpressionsArgumentValueExpression(0, @"Expression"),
                context.GetArgumentBooleanValueExpression(1, @"PredicateExpression", default),
                new TypedConstantResultExpression<System.Object?>(context.GetArgumentValueResult(2, @"DefaultExpression", default))));
            #pragma warning restore CS8620 // Argument cannot be used for parameter due to differences in the nullability of reference types.
        }
    }
    [FunctionName(@"Skip")]
    [FunctionArgument(@"Expression", typeof(System.Collections.IEnumerable))]
    [FunctionArgument(@"CountExpression", typeof(System.Int32))]
    public class SkipExpressionParser : ExpressionParserBase
    {
        protected override CrossCutting.Common.Results.Result<ExpressionFramework.Domain.Expression> DoParse(CrossCutting.Utilities.Parsers.FunctionCallContext context)
        {
            #pragma warning disable CS8620 // Argument cannot be used for parameter due to differences in the nullability of reference types.
            return Result.Success<ExpressionFramework.Domain.Expression>(new ExpressionFramework.Domain.Expressions.SkipExpression(
                context.GetTypedExpressionsArgumentValueExpression(0, @"Expression"),
                context.GetArgumentInt32ValueExpression(1, @"CountExpression")));
            #pragma warning restore CS8620 // Argument cannot be used for parameter due to differences in the nullability of reference types.
        }
    }
    [FunctionName(@"StringConcatenate")]
    [FunctionArgument(@"Expressions", typeof(System.Collections.IEnumerable))]
    public class StringConcatenateExpressionParser : ExpressionParserBase
    {
        protected override CrossCutting.Common.Results.Result<ExpressionFramework.Domain.Expression> DoParse(CrossCutting.Utilities.Parsers.FunctionCallContext context)
        {
            var expressionsResult = context.GetArgumentExpressionResult<System.Collections.Generic.IEnumerable<ExpressionFramework.Domain.Contracts.ITypedExpression<System.String>>>(0, @"Expressions");
            var error = new Result[]
            {
                expressionsResult,
            }.FirstOrDefault(x => !x.IsSuccessful());
            if (error is not null)
            {
                return Result.FromExistingResult<ExpressionFramework.Domain.Expression>(error);
            }
            #pragma warning disable CS8620 // Argument cannot be used for parameter due to differences in the nullability of reference types.
            return Result.Success<ExpressionFramework.Domain.Expression>(new ExpressionFramework.Domain.Expressions.StringConcatenateExpression(
                expressionsResult.Value!));
            #pragma warning restore CS8620 // Argument cannot be used for parameter due to differences in the nullability of reference types.
        }
    }
    [FunctionName(@"StringFind")]
    [FunctionArgument(@"Expression", typeof(System.String))]
    [FunctionArgument(@"FindExpression", typeof(System.String))]
    public class StringFindExpressionParser : ExpressionParserBase
    {
        protected override CrossCutting.Common.Results.Result<ExpressionFramework.Domain.Expression> DoParse(CrossCutting.Utilities.Parsers.FunctionCallContext context)
        {
            #pragma warning disable CS8620 // Argument cannot be used for parameter due to differences in the nullability of reference types.
            return Result.Success<ExpressionFramework.Domain.Expression>(new ExpressionFramework.Domain.Expressions.StringFindExpression(
                context.GetArgumentStringValueExpression(0, @"Expression"),
                context.GetArgumentStringValueExpression(1, @"FindExpression")));
            #pragma warning restore CS8620 // Argument cannot be used for parameter due to differences in the nullability of reference types.
        }
    }
    [FunctionName(@"StringLength")]
    [FunctionArgument(@"Expression", typeof(System.String))]
    public class StringLengthExpressionParser : ExpressionParserBase
    {
        protected override CrossCutting.Common.Results.Result<ExpressionFramework.Domain.Expression> DoParse(CrossCutting.Utilities.Parsers.FunctionCallContext context)
        {
            #pragma warning disable CS8620 // Argument cannot be used for parameter due to differences in the nullability of reference types.
            return Result.Success<ExpressionFramework.Domain.Expression>(new ExpressionFramework.Domain.Expressions.StringLengthExpression(
                context.GetArgumentStringValueExpression(0, @"Expression")));
            #pragma warning restore CS8620 // Argument cannot be used for parameter due to differences in the nullability of reference types.
        }
    }
    [FunctionName(@"StringReplace")]
    [FunctionArgument(@"Expression", typeof(System.String))]
    [FunctionArgument(@"FindExpression", typeof(System.String))]
    [FunctionArgument(@"ReplaceExpression", typeof(System.String))]
    public class StringReplaceExpressionParser : ExpressionParserBase
    {
        protected override CrossCutting.Common.Results.Result<ExpressionFramework.Domain.Expression> DoParse(CrossCutting.Utilities.Parsers.FunctionCallContext context)
        {
            #pragma warning disable CS8620 // Argument cannot be used for parameter due to differences in the nullability of reference types.
            return Result.Success<ExpressionFramework.Domain.Expression>(new ExpressionFramework.Domain.Expressions.StringReplaceExpression(
                context.GetArgumentStringValueExpression(0, @"Expression"),
                context.GetArgumentStringValueExpression(1, @"FindExpression"),
                context.GetArgumentStringValueExpression(2, @"ReplaceExpression")));
            #pragma warning restore CS8620 // Argument cannot be used for parameter due to differences in the nullability of reference types.
        }
    }
    [FunctionName(@"Substring")]
    [FunctionArgument(@"Expression", typeof(System.String))]
    [FunctionArgument(@"IndexExpression", typeof(System.Int32))]
    [FunctionArgument(@"LengthExpression", typeof(System.Int32), false)]
    public class SubstringExpressionParser : ExpressionParserBase
    {
        protected override CrossCutting.Common.Results.Result<ExpressionFramework.Domain.Expression> DoParse(CrossCutting.Utilities.Parsers.FunctionCallContext context)
        {
            #pragma warning disable CS8620 // Argument cannot be used for parameter due to differences in the nullability of reference types.
            return Result.Success<ExpressionFramework.Domain.Expression>(new ExpressionFramework.Domain.Expressions.SubstringExpression(
                context.GetArgumentStringValueExpression(0, @"Expression"),
                context.GetArgumentInt32ValueExpression(1, @"IndexExpression"),
                context.GetArgumentInt32ValueExpression(2, @"LengthExpression", default)));
            #pragma warning restore CS8620 // Argument cannot be used for parameter due to differences in the nullability of reference types.
        }
    }
    [FunctionName(@"Sum")]
    [FunctionArgument(@"Expression", typeof(System.Collections.IEnumerable))]
    [FunctionArgument(@"SelectorExpression", typeof(object))]
    public class SumExpressionParser : ExpressionParserBase
    {
        protected override CrossCutting.Common.Results.Result<ExpressionFramework.Domain.Expression> DoParse(CrossCutting.Utilities.Parsers.FunctionCallContext context)
        {
            #pragma warning disable CS8620 // Argument cannot be used for parameter due to differences in the nullability of reference types.
            return Result.Success<ExpressionFramework.Domain.Expression>(new ExpressionFramework.Domain.Expressions.SumExpression(
                context.GetTypedExpressionsArgumentValueExpression(0, @"Expression"),
                new TypedConstantResultExpression<System.Object?>(context.GetArgumentValueResult(1, @"SelectorExpression", default))));
            #pragma warning restore CS8620 // Argument cannot be used for parameter due to differences in the nullability of reference types.
        }
    }
    [FunctionName(@"Switch")]
    [FunctionArgument(@"Cases", typeof(System.Collections.IEnumerable))]
    [FunctionArgument(@"DefaultExpression", typeof(object))]
    public class SwitchExpressionParser : ExpressionParserBase
    {
        protected override CrossCutting.Common.Results.Result<ExpressionFramework.Domain.Expression> DoParse(CrossCutting.Utilities.Parsers.FunctionCallContext context)
        {
            var casesResult = context.GetArgumentExpressionResult<System.Collections.Generic.IEnumerable<ExpressionFramework.Domain.Case>>(0, @"Cases");
            var error = new Result[]
            {
                casesResult,
            }.FirstOrDefault(x => !x.IsSuccessful());
            if (error is not null)
            {
                return Result.FromExistingResult<ExpressionFramework.Domain.Expression>(error);
            }
            #pragma warning disable CS8620 // Argument cannot be used for parameter due to differences in the nullability of reference types.
            return Result.Success<ExpressionFramework.Domain.Expression>(new ExpressionFramework.Domain.Expressions.SwitchExpression(
                casesResult.Value!,
                new TypedConstantResultExpression<System.Object?>(context.GetArgumentValueResult(1, @"DefaultExpression", default))));
            #pragma warning restore CS8620 // Argument cannot be used for parameter due to differences in the nullability of reference types.
        }
    }
    [FunctionName(@"Take")]
    [FunctionArgument(@"Expression", typeof(System.Collections.IEnumerable))]
    [FunctionArgument(@"CountExpression", typeof(System.Int32))]
    public class TakeExpressionParser : ExpressionParserBase
    {
        protected override CrossCutting.Common.Results.Result<ExpressionFramework.Domain.Expression> DoParse(CrossCutting.Utilities.Parsers.FunctionCallContext context)
        {
            #pragma warning disable CS8620 // Argument cannot be used for parameter due to differences in the nullability of reference types.
            return Result.Success<ExpressionFramework.Domain.Expression>(new ExpressionFramework.Domain.Expressions.TakeExpression(
                context.GetTypedExpressionsArgumentValueExpression(0, @"Expression"),
                context.GetArgumentInt32ValueExpression(1, @"CountExpression")));
            #pragma warning restore CS8620 // Argument cannot be used for parameter due to differences in the nullability of reference types.
        }
    }
    [FunctionName(@"ToCamelCase")]
    [FunctionArgument(@"Expression", typeof(System.String))]
    [FunctionArgument(@"Culture", typeof(System.Globalization.CultureInfo), false)]
    public class ToCamelCaseExpressionParser : ExpressionParserBase
    {
        protected override CrossCutting.Common.Results.Result<ExpressionFramework.Domain.Expression> DoParse(CrossCutting.Utilities.Parsers.FunctionCallContext context)
        {
            #pragma warning disable CS8620 // Argument cannot be used for parameter due to differences in the nullability of reference types.
            return Result.Success<ExpressionFramework.Domain.Expression>(new ExpressionFramework.Domain.Expressions.ToCamelCaseExpression(
                context.GetArgumentStringValueExpression(0, @"Expression"),
                context.GetArgumentValueExpression<System.Globalization.CultureInfo>(1, @"Culture", default)));
            #pragma warning restore CS8620 // Argument cannot be used for parameter due to differences in the nullability of reference types.
        }
    }
    [FunctionName(@"Today")]
    [FunctionArgument(@"DateTimeProvider", typeof(CrossCutting.Common.Abstractions.IDateTimeProvider))]
    public class TodayExpressionParser : ExpressionParserBase
    {
        protected override CrossCutting.Common.Results.Result<ExpressionFramework.Domain.Expression> DoParse(CrossCutting.Utilities.Parsers.FunctionCallContext context)
        {
            var dateTimeProviderResult = context.GetArgumentExpressionResult<CrossCutting.Common.Abstractions.IDateTimeProvider>(0, @"DateTimeProvider", default);
            var error = new Result[]
            {
                dateTimeProviderResult,
            }.FirstOrDefault(x => !x.IsSuccessful());
            if (error is not null)
            {
                return Result.FromExistingResult<ExpressionFramework.Domain.Expression>(error);
            }
            #pragma warning disable CS8620 // Argument cannot be used for parameter due to differences in the nullability of reference types.
            return Result.Success<ExpressionFramework.Domain.Expression>(new ExpressionFramework.Domain.Expressions.TodayExpression(
                dateTimeProviderResult.Value));
            #pragma warning restore CS8620 // Argument cannot be used for parameter due to differences in the nullability of reference types.
        }
    }
    [FunctionName(@"ToLowerCase")]
    [FunctionArgument(@"Expression", typeof(System.String))]
    [FunctionArgument(@"Culture", typeof(System.Globalization.CultureInfo), false)]
    public class ToLowerCaseExpressionParser : ExpressionParserBase
    {
        protected override CrossCutting.Common.Results.Result<ExpressionFramework.Domain.Expression> DoParse(CrossCutting.Utilities.Parsers.FunctionCallContext context)
        {
            #pragma warning disable CS8620 // Argument cannot be used for parameter due to differences in the nullability of reference types.
            return Result.Success<ExpressionFramework.Domain.Expression>(new ExpressionFramework.Domain.Expressions.ToLowerCaseExpression(
                context.GetArgumentStringValueExpression(0, @"Expression"),
                context.GetArgumentValueExpression<System.Globalization.CultureInfo>(1, @"Culture", default)));
            #pragma warning restore CS8620 // Argument cannot be used for parameter due to differences in the nullability of reference types.
        }
    }
    [FunctionName(@"ToPascalCase")]
    [FunctionArgument(@"Expression", typeof(System.String))]
    [FunctionArgument(@"Culture", typeof(System.Globalization.CultureInfo), false)]
    public class ToPascalCaseExpressionParser : ExpressionParserBase
    {
        protected override CrossCutting.Common.Results.Result<ExpressionFramework.Domain.Expression> DoParse(CrossCutting.Utilities.Parsers.FunctionCallContext context)
        {
            #pragma warning disable CS8620 // Argument cannot be used for parameter due to differences in the nullability of reference types.
            return Result.Success<ExpressionFramework.Domain.Expression>(new ExpressionFramework.Domain.Expressions.ToPascalCaseExpression(
                context.GetArgumentStringValueExpression(0, @"Expression"),
                context.GetArgumentValueExpression<System.Globalization.CultureInfo>(1, @"Culture", default)));
            #pragma warning restore CS8620 // Argument cannot be used for parameter due to differences in the nullability of reference types.
        }
    }
    [FunctionName(@"ToUpperCase")]
    [FunctionArgument(@"Expression", typeof(System.String))]
    [FunctionArgument(@"Culture", typeof(System.Globalization.CultureInfo), false)]
    public class ToUpperCaseExpressionParser : ExpressionParserBase
    {
        protected override CrossCutting.Common.Results.Result<ExpressionFramework.Domain.Expression> DoParse(CrossCutting.Utilities.Parsers.FunctionCallContext context)
        {
            #pragma warning disable CS8620 // Argument cannot be used for parameter due to differences in the nullability of reference types.
            return Result.Success<ExpressionFramework.Domain.Expression>(new ExpressionFramework.Domain.Expressions.ToUpperCaseExpression(
                context.GetArgumentStringValueExpression(0, @"Expression"),
                context.GetArgumentValueExpression<System.Globalization.CultureInfo>(1, @"Culture", default)));
            #pragma warning restore CS8620 // Argument cannot be used for parameter due to differences in the nullability of reference types.
        }
    }
    [FunctionName(@"TrimEnd")]
    [FunctionArgument(@"Expression", typeof(System.String))]
    [FunctionArgument(@"TrimCharsExpression", typeof(System.Char[]), false)]
    public class TrimEndExpressionParser : ExpressionParserBase
    {
        protected override CrossCutting.Common.Results.Result<ExpressionFramework.Domain.Expression> DoParse(CrossCutting.Utilities.Parsers.FunctionCallContext context)
        {
            #pragma warning disable CS8620 // Argument cannot be used for parameter due to differences in the nullability of reference types.
            return Result.Success<ExpressionFramework.Domain.Expression>(new ExpressionFramework.Domain.Expressions.TrimEndExpression(
                context.GetArgumentStringValueExpression(0, @"Expression"),
                context.GetArgumentValueExpression<System.Char[]>(1, @"TrimCharsExpression", default)));
            #pragma warning restore CS8620 // Argument cannot be used for parameter due to differences in the nullability of reference types.
        }
    }
    [FunctionName(@"Trim")]
    [FunctionArgument(@"Expression", typeof(System.String))]
    [FunctionArgument(@"TrimCharsExpression", typeof(System.Char[]), false)]
    public class TrimExpressionParser : ExpressionParserBase
    {
        protected override CrossCutting.Common.Results.Result<ExpressionFramework.Domain.Expression> DoParse(CrossCutting.Utilities.Parsers.FunctionCallContext context)
        {
            #pragma warning disable CS8620 // Argument cannot be used for parameter due to differences in the nullability of reference types.
            return Result.Success<ExpressionFramework.Domain.Expression>(new ExpressionFramework.Domain.Expressions.TrimExpression(
                context.GetArgumentStringValueExpression(0, @"Expression"),
                context.GetArgumentValueExpression<System.Char[]>(1, @"TrimCharsExpression", default)));
            #pragma warning restore CS8620 // Argument cannot be used for parameter due to differences in the nullability of reference types.
        }
    }
    [FunctionName(@"TrimStart")]
    [FunctionArgument(@"Expression", typeof(System.String))]
    [FunctionArgument(@"TrimCharsExpression", typeof(System.Char[]), false)]
    public class TrimStartExpressionParser : ExpressionParserBase
    {
        protected override CrossCutting.Common.Results.Result<ExpressionFramework.Domain.Expression> DoParse(CrossCutting.Utilities.Parsers.FunctionCallContext context)
        {
            #pragma warning disable CS8620 // Argument cannot be used for parameter due to differences in the nullability of reference types.
            return Result.Success<ExpressionFramework.Domain.Expression>(new ExpressionFramework.Domain.Expressions.TrimStartExpression(
                context.GetArgumentStringValueExpression(0, @"Expression"),
                context.GetArgumentValueExpression<System.Char[]>(1, @"TrimCharsExpression", default)));
            #pragma warning restore CS8620 // Argument cannot be used for parameter due to differences in the nullability of reference types.
        }
    }
    [FunctionName(@"True")]
    public class TrueExpressionParser : ExpressionParserBase
    {
        protected override CrossCutting.Common.Results.Result<ExpressionFramework.Domain.Expression> DoParse(CrossCutting.Utilities.Parsers.FunctionCallContext context)
        {
            #pragma warning disable CS8620 // Argument cannot be used for parameter due to differences in the nullability of reference types.
            return Result.Success<ExpressionFramework.Domain.Expression>(new ExpressionFramework.Domain.Expressions.TrueExpression(
                ));
            #pragma warning restore CS8620 // Argument cannot be used for parameter due to differences in the nullability of reference types.
        }
    }
    [FunctionName(@"TryCast")]
    [FunctionArgument(@"SourceExpression", typeof(object))]
    [FunctionArgument(@"DefaultExpression", typeof(object), false)]
    public class TryCastExpressionParser : ExpressionParserBase
    {
        protected override CrossCutting.Common.Results.Result<ExpressionFramework.Domain.Expression> DoParse(CrossCutting.Utilities.Parsers.FunctionCallContext context)
        {
            var typeResult = context.FunctionCall.Name.GetGenericTypeResult();
            if (!typeResult.IsSuccessful())
            {
                return Result.FromExistingResult<ExpressionFramework.Domain.Expression>(typeResult);
            }
            #pragma warning disable CS8620 // Argument cannot be used for parameter due to differences in the nullability of reference types.
            return Result.Success<ExpressionFramework.Domain.Expression>((ExpressionFramework.Domain.Expression)System.Activator.CreateInstance(typeof(ExpressionFramework.Domain.Expressions.TryCastExpression<>).MakeGenericType(typeResult.Value!)));
            #pragma warning restore CS8620 // Argument cannot be used for parameter due to differences in the nullability of reference types.
        }
    }
    [FunctionName(@"TypedChained")]
    [FunctionArgument(@"Expressions", typeof(System.Collections.IEnumerable))]
    public class TypedChainedExpressionParser : ExpressionParserBase
    {
        protected override CrossCutting.Common.Results.Result<ExpressionFramework.Domain.Expression> DoParse(CrossCutting.Utilities.Parsers.FunctionCallContext context)
        {
            return ParseTypedExpression(typeof(TypedChainedExpression<>), 0, @"Expressions", context);
        }
    }
    [FunctionName(@"TypedConstant")]
    [FunctionArgument(@"Value", typeof(object))]
    public class TypedConstantExpressionParser : ExpressionParserBase
    {
        protected override CrossCutting.Common.Results.Result<ExpressionFramework.Domain.Expression> DoParse(CrossCutting.Utilities.Parsers.FunctionCallContext context)
        {
            return ParseTypedExpression(typeof(TypedConstantExpression<>), 0, @"Value", context);
        }
    }
    [FunctionName(@"TypedConstantResult")]
    [FunctionArgument(@"Value", typeof(CrossCutting.Common.Results.Result<object>))]
    public class TypedConstantResultExpressionParser : ExpressionParserBase
    {
        protected override CrossCutting.Common.Results.Result<ExpressionFramework.Domain.Expression> DoParse(CrossCutting.Utilities.Parsers.FunctionCallContext context)
        {
            return ParseTypedExpression(typeof(TypedConstantResultExpression<>), 0, @"Value", context);
        }
    }
    [FunctionName(@"TypedContext")]
    public class TypedContextExpressionParser : ExpressionParserBase
    {
        protected override CrossCutting.Common.Results.Result<ExpressionFramework.Domain.Expression> DoParse(CrossCutting.Utilities.Parsers.FunctionCallContext context)
        {
            var typeResult = context.FunctionCall.Name.GetGenericTypeResult();
            if (!typeResult.IsSuccessful())
            {
                return Result.FromExistingResult<ExpressionFramework.Domain.Expression>(typeResult);
            }
            #pragma warning disable CS8620 // Argument cannot be used for parameter due to differences in the nullability of reference types.
            return Result.Success<ExpressionFramework.Domain.Expression>((ExpressionFramework.Domain.Expression)System.Activator.CreateInstance(typeof(ExpressionFramework.Domain.Expressions.TypedContextExpression<>).MakeGenericType(typeResult.Value!)));
            #pragma warning restore CS8620 // Argument cannot be used for parameter due to differences in the nullability of reference types.
        }
    }
    [FunctionName(@"TypedDelegate")]
    [FunctionArgument(@"Value", typeof(System.Func<System.Object?>))]
    public class TypedDelegateExpressionParser : ExpressionParserBase
    {
        protected override CrossCutting.Common.Results.Result<ExpressionFramework.Domain.Expression> DoParse(CrossCutting.Utilities.Parsers.FunctionCallContext context)
        {
            return ParseTypedExpression(typeof(TypedDelegateExpression<>), 0, @"Value", context);
        }
    }
    [FunctionName(@"TypedDelegateResult")]
    [FunctionArgument(@"Value", typeof(System.Func<System.Object?>))]
    public class TypedDelegateResultExpressionParser : ExpressionParserBase
    {
        protected override CrossCutting.Common.Results.Result<ExpressionFramework.Domain.Expression> DoParse(CrossCutting.Utilities.Parsers.FunctionCallContext context)
        {
            return ParseTypedExpression(typeof(TypedDelegateResultExpression<>), 0, @"Value", context);
        }
    }
    [FunctionName(@"TypedField")]
    [FunctionArgument(@"Expression", typeof(object))]
    [FunctionArgument(@"FieldNameExpression", typeof(System.String))]
    public class TypedFieldExpressionParser : ExpressionParserBase
    {
        protected override CrossCutting.Common.Results.Result<ExpressionFramework.Domain.Expression> DoParse(CrossCutting.Utilities.Parsers.FunctionCallContext context)
        {
            var typeResult = context.FunctionCall.Name.GetGenericTypeResult();
            if (!typeResult.IsSuccessful())
            {
                return Result.FromExistingResult<ExpressionFramework.Domain.Expression>(typeResult);
            }
            #pragma warning disable CS8620 // Argument cannot be used for parameter due to differences in the nullability of reference types.
            return Result.Success<ExpressionFramework.Domain.Expression>((ExpressionFramework.Domain.Expression)System.Activator.CreateInstance(typeof(ExpressionFramework.Domain.Expressions.TypedFieldExpression<>).MakeGenericType(typeResult.Value!)));
            #pragma warning restore CS8620 // Argument cannot be used for parameter due to differences in the nullability of reference types.
        }
    }
    [FunctionName(@"Where")]
    [FunctionArgument(@"Expression", typeof(System.Collections.IEnumerable))]
    [FunctionArgument(@"PredicateExpression", typeof(System.Boolean))]
    public class WhereExpressionParser : ExpressionParserBase
    {
        protected override CrossCutting.Common.Results.Result<ExpressionFramework.Domain.Expression> DoParse(CrossCutting.Utilities.Parsers.FunctionCallContext context)
        {
            #pragma warning disable CS8620 // Argument cannot be used for parameter due to differences in the nullability of reference types.
            return Result.Success<ExpressionFramework.Domain.Expression>(new ExpressionFramework.Domain.Expressions.WhereExpression(
                context.GetTypedExpressionsArgumentValueExpression(0, @"Expression"),
                context.GetArgumentBooleanValueExpression(1, @"PredicateExpression")));
            #pragma warning restore CS8620 // Argument cannot be used for parameter due to differences in the nullability of reference types.
        }
    }
    [FunctionName(@"Year")]
    [FunctionArgument(@"Expression", typeof(System.DateTime))]
    public class YearExpressionParser : ExpressionParserBase
    {
        protected override CrossCutting.Common.Results.Result<ExpressionFramework.Domain.Expression> DoParse(CrossCutting.Utilities.Parsers.FunctionCallContext context)
        {
            #pragma warning disable CS8620 // Argument cannot be used for parameter due to differences in the nullability of reference types.
            return Result.Success<ExpressionFramework.Domain.Expression>(new ExpressionFramework.Domain.Expressions.YearExpression(
                context.GetArgumentDateTimeValueExpression(0, @"Expression")));
            #pragma warning restore CS8620 // Argument cannot be used for parameter due to differences in the nullability of reference types.
        }
    }
}
#nullable disable
